<<TableOfContents()>>

== Термины и определения ==

'''Система миграций''' — это система служебных библиотек и скриптов, позволяющая определять и контролировать переходы между различными версиями базы данных, в частности структуры базы данных.

Преимущество системы миграций в том, что она позволяет прозрачно изменять структуру БД при развёртывании приложения поверх уже существующей установки БД более ранней (или поздней) версии приложения без необходимости полностью пересоздавать БД (возможно с потерей имеющихся данных).

Таким образом развёртывание на уже существующую базу происходит
    a. очень быстро (т.к. база не пересоздаётся, особенно актуально при большой и сложной структуре БД с большим количеством дополнительных исходных данных, например базы городов и стран),
    b. без потери существующих данных (что актуально при обновлении существуюшего живого приложения на тестовом или продакшн сервере).

Система миграций включает в себя следующие компоненты:
    1. '''Фреймворк''' (библиотеку), создающий среду для выполнения миграционных скриптов и предоставляющий удобный инструментарий для работы со структурой БД из миграционного скрипта.
    2. '''Инструментарий''' (например набор консольных скриптов) для удобства создания миграционных скриптов, их запуска для накатывания/откатывания версии БД, выдачи информации о текущей версии БД и т.д..
    3. '''Репозиторий''' (хранилище) миграционных скриптов (обычно каталог), в котором хранятся миграционные скрипты, именованные в соответствии с определёнными правилами.
    4. '''Миграционные скрипты''', описывающие реальные изменения в структуре БД, необходимые для перехода от версии ''M'' к версии ''M+1''.

Система миграций строится вокруг концепции '''миграционных скриптов'''. Миграционный скрипт — минимальная единица изменения БД, по сути программа (скрипт), описывающая изменения в структуре БД, переход БД от версии ''M'' к версии ''M+1''.

Очень важно, чтобы каждый миграционный скрипт был написан максимально аккуратно, т.к. он будет работать на живой БД, в итоге даже на продакшн БД. Об этом необходимо помнить постоянно, пока скрипт пишется. Скрипт обязательно должен приводить БД из одного стабильного состояния в другое стабильное состояние.

== Миграции в питоне: python-migrate ==

Для Python есть готовая система миграций — python-migrate. Владельцы Debian-а могут поставить этот пакет из репозиториев:

{{{
#!code sh
$ sudo apt-get install python-migrate
}}}

Тем, у кого стоит Windows, можно сходить на [[http://code.google.com/p/sqlalchemy-migrate/|официальный сайт]] этого пакета.

Там же рекомендуется почитать документацию по нему. Ещё полезно будет запустить из командной строки `migrate --help` и посмотреть на список доступных команд, или `migrate help <команда>` для получения справки о конкретной команде.

Ниже я изложу только использование этого пакета в приминении к нашему проекту с учётом того, что он уже настроен и используется в проекте.

=== Внутренние структуры python-migrate ===

Python-migrate добавляет в систему скрипт `migrate` для управления миграциями. Для контроля версии базы данных он добавляет в БД таблицу `migrate_version` с трёмя полями и единственной строчкой:
    * `repository_id varchar(255)` — имя репозитория, используемого для контроля версии БД,
    * `repository_path text` — путь к каталогу, в котором содержится репозиторий с миграционными скриптами и конфигами,
    * `version integer` — номер версии, по сути номер последнего применённого миграционного скрипта.

Репозиторий python-migrate представляет собой каталог, в котором содержатся следующий файлы и каталоги (указаны реально значимые):
    * `manage.py` — файл-скрипт, обёртка над системой миграций (на самом деле либой, которая и работает с миграциями) для удобного управления заданным репозиторием, без необходимости каждый раз указывать общесистемному скрипту `migrate` каталог с репозиторием,
    * `migrate.cfg` — файл с настройками репозитория, где указаны имя репозитория, поддерживаемые СУБД, таблица в БД с номером версии (`migrate_version` по-умолчанию) и т.п.,
    * `versions` — каталог с собственно миграционными скриптами.

Каждый миграционный скрипт называется следующим образом: `<номер версии>_<описание ревизии>.py`.
Кроме того python-migrate поддерживает чистые SQL-миграции с простыми SQL-командами. Такие скрипты идут парами: `<номер версии>_<имя СУБД>_upgrade.sql` и `<номер версии>_<имя СУБД>_downgrade.sql`. Здесь
    * ''номер версии'' — номер скрипта по порядку, в репозитории не может быть двух скриптов с одним и тем же номером (даже если они и называются по разному), должен состоять из трёх цифр, если меньше сотни, до добиывается лидирующими нулями (`001`, `002` и т.д.),
    * ''имя СУБД'' — имя поддерживаемой БД, например `postgres` или `mysql`,
    * ''описание ревизии'' — осмысленное название ревизии, описывающее производимые скриптом изменения, чисто для человеческого удобства. Состоит из строчных латинских букв, цифр и знака подчёркивания.

=== Полезные команды python-migrate ===

Как уже говорил выше, python-migrate добавляет общесистемный скрипт для управления миграциями `migrate`. Использовать его напрямую, однако, вам вряд ли придётся =)
Пожалуй единственное действие, которое можно сделать только с помощью него, это создать новый репозиторий миграций:

{{{
#!code sh
$ migrate create ./migrations migrations
}}}

Первый параметр — каталог для хранения миграций, второй — имя репозитория. Обычно они совпадают для удобства.

У нас репозиторий уже создан, лежит в корне проекта под именем `migrations` и имеет имя (не поверите) `migrations`.

Все дальнейшие действия с репозиторием можно (и нужно) совершать с помощью скрипта `manage.py` в каталоге с репозиторием. Подробную справку об опциях, которые принимает `manage.py`, можно получить из оф. доки или запустив этот скрипт в параметром `--help`.

Есть единственный параметр, который не описан нигде и который является нашим расширением: `--inifile=INIFILE`. С помощью этого параметра можно указать ini-файл проекта, из которого надо брать настройки БД для операций с ними. Если указать этот параметр, то указывать `URL` или `--url=URL`, как описано во всей официальной справке, уже не нужно. Путь к ini-файлу указывать не нужно: по умолчанию (если имя ini-файла не начинается на `/`) он устанавливается относительно каталога проекта. Расширение `.ini` тоже можно опускать: оно дополнится автоматически.

Полезные команды (предполагается, что текущий каталог — каталог с проектом):
{{{
#!code sh
$ cd ./migrations

# создаёт миграционный скрипт migrations/versions/###_this_migration_does_this_and_that.py, номер назначается автоматически
# прибавлением 1 к максимальному номеру существующих скриптов:
$ ./manage.py script "this migration does this and that" 

# аналогично создаёт SQL-миграцию для СУБД Postgres — файлы с именами ###_postgres_upgrade.sql и ###_postgres_downgrade.sql:
$ ./manage.py script_sql postgres

# получает текущуй номер ревизии в репозитории:
$ ./manage.py version
14

# поместить БД, заданную в данном ini-файле, под контроль версий данного репозитория,
# при этом установить, что текущая структура БД соответствует ревизии 13 (если опустить,
# то БД будет считаться соответствующей ревизии 0, то есть следующем апгрейде будут выполненны
# все скрипты, включая самый первый, что для уже существующей БД может быть некорректно:
$ ./manage.py version_control --inifile=development.ini 13

# получает текущую версию БД, указанную в данном ini-файле проекта:
$ ./manage.py db_version --inifile=development.ini
13

# апгрейд базы данных, указанной в ini-файле, до максимально существующей версии в репозитории:
$ ./manage.py upgrade --inifile=development.ini
13 -> 14...
done

# даунгрейд базы данных, указанной в ini-файле, до заданной версии:
$ ./manage.py downgrade --inifile=development.ini 12
14 -> 13...
done
13 -> 12...
done
}}}

Это основные команды. Кроме того есть несколько экспериментальных и редко используемых команд, которые я здесь не описываю. Если интересно, то про них можно почитать в официальной документации. 

Команду `version_control` скорее всего не придётся выполнять никогда, т.к. при выполнении `paster setup-app` с python-migrate установленной в системе, БД будет автоматически помещена под контроль версий с указанием последней ревизии в репозитории. Единственный случай, когда она может понадобиться, это если приложение было установлено до того, как в системы поставили python-migrate, и БД оказалась вне контроля версий.

Скорее всего самыми частыми командами будут `script`, `upgrade` и `downgrade`.

При выполнении команд `script` и `script_sql` номер новой ревизии определяется как следующий за максимальным номером, под которым идут существующие миграционные скрипты, при этом учитываются не только `*.py` и `*.sql` файлы, но и `*.pyc` файлы. То есть если у вас были миграции `001_firtrev.py` и `002_secondrev.py` и вы удалили `002_secondrev.py`, то будте готовы, что выполнение `manage.py script 2ndrev` создаст ревизию `003_2ndrev.py`, а не `002_2ndrev.py`, как ожидалось, если вы забыли удалить скомпилированный файл `002_secondrev.pyc` из `migrations/versions`.

=== Написание миграционных скриптов ===

TODO

== Подводные камни: о чём нужно помнить, работаю с миграциями ==

TODO

== Ссылки по теме ==

TODO
