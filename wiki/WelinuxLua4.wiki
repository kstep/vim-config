Введение в Lua для программистов — часть 2.2

В <a href="http://welinux.ru/post/5192/">прошлой части</a> я рассказал про таблицы, а в этой хочу поделиться своими знаниями о функциях в Lua.

[cut]
<h1>Без рода, без племени...</h1>
...и без имени — это функции в Lua. Строго говоря все функции в Lua являются <s>лямбда-функциями</s> анонимными функциями. И пусть вас не обманывает тот синтаксис, который я применял до сих пор: он только для того, чтобы не смущать вас до этого момента. «Имена» функций — это такие же переменные, как и все остальные, содержащие в себе числа, строки, таблицы и т.д. (Говоря другими словами функции занимают ту же область имён, что и все остальные переменные, но это некоторое упрощение в угоду понятности.)

Следующие два кусочка кода являются идентичными:

<code lang='lua'>
function out(x)
    print(x)
end

out = function (x)
    print(x)
end
</code>

То есть запись <b>function name(args) ... end</b> — это всего навсего синтаксический сахар, а реально это операция присваивания переменной <i>name</i> значения в виде лямбда-функции. Ниже я буду применять синтаксис с присваиванием переменной значения типа <b>function</b>, чтобы вы привыкли к этой мысли, но обычно всё же лучше писать в «сахарном» виде: так привычнее и понятнее.

Процедур в Lua не существует: это по сути те же функции, которые возвращают <b>nil</b>, а это происходит, если в функции нет оператора <b>return</b> (ну или он есть, но в нём не задано значение для возврата, или явно задано значение <b>nil</b> — вне функции разницы не будет никакой).

Естественно, передавать функции можно несколько значений. Естественно, возвращать можно тоже несколько значений. И конечно же есть синтаксис для передачи произвольного числа параметров. Но — по порядку.

<code lang='lua'>
-- функция принимает два аргумента, возвращает один
sumof2 = function (a, b)
    return a + b
end

-- функция принимает один аргумент, возвращает два
double2 = function (a)
    return a + a, a * a
end

-- функция принимает два аргумента, возвращает тоже два
plusminus = function (a, b)
    return a + b, a - b
end

-- вызовы можно комбинировать
print(sumof2(plusminus(double2(10))))
-- цепочка вызовов получается такая:
-- double2(10) -> 20, 100
--     plusminus(20, 100) -> 120, -80
--         sumof2(120, -80) -> 40
--             print(40)
</code>

Все аргументы функций являются необязательными: если функции передано меньше аргументов, чем у неё объявлено формальный параметров, то все параметры, для которых значений не нашлось, получат значение <b>nil</b>. Более того, можно передавать функции и больше аргументов, чем у неё объявлено параметров в прототипе: «лишние» аргументы будут просто проигнорированы. Следить за корректностью и существованием входных параметров предстоит программисту. Значений по-умолчанию для формальных параметров тоже не предусмотрено, так что выставляйте их сами. В общем ситуация чем-то похожа на ту, что в Perl-е. Примеры:

<code lang='lua'>
$ lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
> print2 = function (a, b) print(a, b) end
> print2(1, 2)
1	2
> print2(1, 2, 3)
1	2
> print2(1)
1	nil
</code>

Пример проверки существования обязательного аргумента и выставление значения по-умолчанию для необязательного:

<code lang='lua'>
test_func = function (a, b, c)
    if not a then return end -- a - обязательный параметр
    b = b or 10 -- b по-умолчанию равен 10
    if not c then c = 20 end -- с по-умолчанию равен 20 (аналогично предыдущей строчки, но длиннее)
    return a + b * c
end
</code>

А если мы хотим функцию наподобие С-шной <b>printf(format, ...)</b>? Легко!

<code lang='lua'>
printf = function(format, ...)
    print(format)
    for i = 1, arg.n do
        print(i, arg[i])
    end
end

printf("format string", "one", nil, "two", 3, nil)
</code>

Результат:
<spoiler>
format string
1	one
2	nil
3	two
4	3
5	nil
</spoiler>

(Ясно, что сейчас это далеко не <b>printf()</b>, но её мы напишем попозже, а сейчас просто разберём этот пример.)

Итак, в качестве последнего значения в списке формальных параметров у функции может быть многоточие. Оно «поймает» все аргументы, для которых не хватило места в указанных до него параметрах, при этом в самой функции будет доступна специальная локальная таблица <b>arg</b>, которая содержит один элемент с ключём <b>n</b>, в котором указано число аргументов, «пойманных» многоточием, а в части-массиве этой таблице будут лежать все переданные опциональные аргументы. Думаю не надо объяснять зачем передаётся число аргументов, а для итерации по этим аргументам рекомендуется использовать цикл <b>for i = 1, arg.n do...</b>, а не <b>for k, v in ipairs(arg) do...</b>? Ведь среди переданных аргументов могут быть <b>nil</b>-ы, и итератор <b>ipairs()</b> споткнётся на первом же из них. Если же в качестве верхней границы в цикле со счётчиком использовать <b>#arg</b>, то цикл тоже срежется совсем не там где надо, особенно если <b>nil</b> будет передан в последних рядах. (За подробностями прошу в предыдущую статью.)

Кроме того если функция использует многоточие в своём прототипе, то можно это же многоточие использовать и в самом теле функции, во время выполнение оно будет заменено на все «пойманные» таким образом аргументы:

<code lang='lua'>
> ellipsis = function(...) if ... then print(...) end end
> ellipsis(1, 2, 3)
1	2	3
> ellipsis(nil, 2, 3)
> ellipsis(1, nil, 3)
1	nil	3
> ellipsis(1, nil, nil)
1	nil	nil
> ellipsis(false, 2, 3)
>
</code>

Функция <b>print()</b> принимает любое число аргументов, поэтому ей просто напрямую будут переданы все аргументы, указанные в нашей тестовой функции, а вот оператор <b>if</b> ожидает только одно булево значение, так что для него многоточие отдаст только первый аргумент, поэтому если первым аргументом будет значение «ложь», то проверка пройдена не будет. (Можете ещё для проверки попробовать выполнить код <i>if 1, 2, 3 then print("yes") end</i> и получить синтаксическую ошибку, чтобы убедиться, что многоточие в случае с <b>if</b>-ом не будет разворачиваться в полный список.)

Ну и напоследок пара полезных вещей для адептов функционального программирования: Lua-поддерживает оптимизацию хвостовых рекурсий и функции более высокого порядка.

<b>Achtung!</b> Ниже идёт более глубокий материал, который требует чуть лучшей подготовки и может быть не всеми сразу понят. Если вы запнулись на первом же примере после этого абзаца, можете пропустить часть статьи до самых итогов, а сюда вернуться попозже, когда прокачаете навык чуть лучше «функциональное программирование».

Классический пример хвостовой рекурсии:

<code lang='lua'>
factorial = function (n, m)
    if n < 0 then return end
    if n == 0 then return m or 1 end
    return factorial(n - 1, (m or 1) * n)
end
</code>

Этот код не вызовет разрастание стека вызовов, т.к. в самом конце возврат с единственным вызовом функции самоей себя. Прозреваю вопрос о том, почему здесь нужен второй параметр (по сути аккумулятор) и рекурсивный вызов такой странный. Отвечу сразу. Более привычный вариант

<code lang='lua'>
factorial = function (n)
    if n < 0 then return end
    if n == 0 then return 1 end
    return n * factorial(n - 1)
end
</code>

не является хвостовой рекурсией, потому что в конце на самом деле идёт не чистый вызов функции, там идёт вычисление выражения, и в составе выражения есть вызов функции, то есть из функции придётся вернуться назад сюда же, чтобы произвести произведение и вернуть его на выходе.

Пример функции, которая возвращает другую:

<code lang='lua'>
square_eq = function (a, b, c)
    return function (x)
        return a*x*x + b*x + c
    end
end
</code>

Кроме того здесь же динамически создаётся замыкание, в которое попадают значение a, b и c: после выхода из функции square_eq() они перестают существовать, т.к. являются локальными для этой функции, но функция, которая была динамически создана и возвращена, получает свои собственные копии этих переменных, они продолжают жить в этой клетушке, которая называется замыканием. Обратиться к этим копиям извне замыкания, естественно, невозможно.

На сегодня, пожалуй, всё, а то, чувтсвую, начинаю лезть в дебри. Посему подвожу <b>итог</b>.

В этой статье мы получили предтавление об особенностях функций в Lua: узнали, что все они анонимны и хранятся в переменных наравне с другими данными, что их можно динамически создавать, передавать и возвращать как параметр в другие функции, что аргументы функций никак специально не проверяются, узнали как, можно передавать произвольное число аргументов, а также увидели пару простых примеров применения функционального программирования.

В следующей серии я дам краткий обзор типов данных <b>userdata</b> и <b>thread</b> (обещаю быть кратким, благо про них можно не так уж много рассказать на этом этапе, как про таблицы и функции), расскажу наконец-то как объявлять локальные переменные (и вообще про область видимости переменных) и покончу, наконец, с затянувшейся второй частью.
