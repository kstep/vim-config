Введение в Lua для начинающих программистов.

Для чего: рассказать про Lua начинающим программистам, способствовать популяризации этого замечательного языка =)

Кому: людям, для которых слова «цикл», «условный оператор», «переменная», «тип» и «функция» имеют некоторое значение, хотя бы на уровне школьного паскаля.

[cut]
<h1>Введение</h1>
<h2>Введение первое, академическое</h2>
Если говорить академическим языком, <a href="http://ru.wikipedia.org/wiki/Lua">Lua</a> — это интерпретируемый язык со <a href="http://ru.wikipedia.org/wiki/Строгая_типизация">слабой</a> <a href="http://ru.wikipedia.org/wiki/Динамическая_типизация">динамической</a> типизацией данных, поддерживающий программирование в <a href="http://ru.wikipedia.org/wiki/Императивное_программирование">императивном</a>, <a href="http://ru.wikipedia.org/wiki/Функциональное_программирование">функциональном</a> и <a href="http://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование">объектно-ориентированном</a> (с <a href="http://ru.wikipedia.org/wiki/Прототипное_программирование">прототипным наследованием</a>) стилях. В нём есть <a href="http://ru.wikipedia.org/wiki/Замыкание_(программирование)">замыкания</a>, <a href="http://ru.wikipedia.org/wiki/Сопрограмма">сопрограммы</a>, а функции, соответственно, <a href="http://ru.wikipedia.org/wiki/Объект_первого_класса">объекты первого класса</a>.

Фух, лимит ссылок на википедию я исчерпал. Кому интересны все эти термины, считайте эту часть поводом с ними ознакомиться поближе, остальные могут проснуться и читать дальше.

<spoiler>Да, эта часть написана чтобы потешить самолюбие автора и утвердить его ЧСВ.</spoiler>

<h2>Введение второе, практическое</h2>
Про историю языка я писать не буду, кому интересно прочитает в вики. Здесь я расскажу только для чего, собственно, этот язык был создан.

Этот язык создан быть встраиваемым, его дао — расширение функциональности программ на C/C++, описание скриптов и конфигураций, и в этой области он великолепен. Впрочем, он может быть использован как самостоятельный скриптовый язык, но в таком виде он встречается достаточно редко. В связи с этим у языка имеется очень хорошо описанная «оборотная сторона»: достаточно удобный C-интерфейс, позволяющий свободно передавать данные между C и Lua частями программы, делать вызовы C-функций из Lua и наоборот и множество других интересных штук, при этом C-часть придерживается си-стиля, а луа часть — луа-стиля, отлично друг друга дополняют и не кажутся чужеродными в своей языковой среде.

Где можно встретить Луа? Большинство современных игр содержат скрипты на нём, начиная с WoW и кончая Цивилизацией. Кроме того он используется в нежно любимом мною WM <a href="http://awesome.naquadah.org/">Awesome</a>, а также в браузере <a href="http://luakit.org/projects/luakit">Luakit</a>, в котором я пишу эти статью (на самом деле я пишу её в виме, но на мылинукс пощу именно из луакита).

Да, сразу оговорюсь, что речь пойдёт о Lua версии 5.1, как наиболее актуальной.

Повествование я разделю на следующие части:

<ol>
<li>Здесь же ниже, про базовые понятия, операторы и особенности языка,</li><li>про типы и структуры данных,</li><li>расширенные сведения о всяких вкусностях,</li><li>введение в объектные возможности языка,</li><li>введение в функциональные возможности языка,</li><li>краткое описание стандартных модулей со ссылками и реверансами,</li><li>для особо интересующихся — «теневая сторона языка» с точки зрения C.</li>
</ol>

<h1>Часть первая, скучная</h1>
<b>или Галопом по европам</b>

По традиции начнём с классической программы:

<b>hworld.lua</b>
<code lang='lua'>
print('Hello, world!')
</code>

Запускаем:

<code lang='bash'>
$ lua ./hworld.lua
Hello, world!
</code>

Всё просто, да? Теперь завернём в функцию.

<code lang='lua'>
function hworld()
    print('Hello, world!')
end

hworld()
</code>

Ещё у нас есть циклы <b>for</b>, <b>while</b> и <b>repeat/until</b>, знакомые по старичку Паскалю:

<code lang='lua'>
function bottles(i)
    print('В ящике осталось ' .. i .. ' бутылок пива.')
end

for i = 10, 1, -1 do
    bottles(i)
end

for i = 1, 10 do
    bottles(i)
end

i = 10
while i >= 1 do
    bottles(i)
    i = i - 1
end

i = 10
repeat
    bottles(i)
    i = i - 1
until i < 1
</code>

Здесь же знакомимся с операцией <s>конкатенации</s> объединения строк («..»).

Условия у нас тоже имеются:

<code lang='lua'>
user_number = io.read('*number')
if not user_number then
    print('Какое же это число? Это фигня какая-то =(')
elseif i < 0 then
    print('Вау, отрицательно число!')
elseif i ~= 0 then
    print('Это число явно не нуль, значит натурально, да?')
else
    print('Прозреваю ошибку деления на это число.')
end
</code>

А вот операции <b>switch</b> не наблюдается, её можно эмулировать как обычно кучей <b>if/elseif/.../else/end</b> или... другим способом (о котором, наверное, догадаются питонщики, но про это позже, когда про структуры данных буду рассказывать).

Теперь разбор полётов.

Здесь в первый раз мы видим использование модуля: <b>io</b> — это стандартный модуль для работы с вводом-выводом.
Кроме того здесь же видно несколько особенностей Lua. А именно:
<ol><li>операция «не равно» записывается как «~=»,</li><li>ноль в <s>булевом</s> логическом контексте считается истиной</li><ol>.
Если первая особенность чисто синтаксическая, то вторая имеет для нас достаточно серьёзные последствия, особенно если раньше вы привыкли, что ноль и пустая строка — это ложь. Для Lua ложны только два значения: <b>nil</b> и <b>false</b>, всё остальное истинно (включая классическое <b>true</b>). <b>nil</b> — это пустой указатель, пустое значение, аналог питоновскому <b>None</b>, сишному <b>NULL</b> и паскалевскому <b>Nil</b>. Здесь <b>io.read('*number')</b> просит прочитать из стандартного ввода число, и если юзер ввёл нечто, в число непреобразуемое, то результатом этого вызова будет будет <b>nil</b>. Это верно для многих случаев: очень часто в стандартных модулях <b>nil</b> используется как флаг ошибки, так что часто можно было бы написать так:

<code lang='lua'>
repeat
    io.write('Введите-ка число: ')
    num = io.read('*number')
until num
</code>

И этот код будет прекрасно работать, даже если юзер введёт просто «0». (Здесь <b>io.write()</b>, как вы наверное уже догадались, отличается от <b>print()</b> тем, что не выводит в конце строки символ перевода этой самой строки.)

Кроме того обращаю внимание на общую канву построения блоков в Lua: почти все операторы группируются в блоки вида <b>do ... end</b> (кроме <b>repeat/until</b>, но это единичное исключение). <b>end</b> — это универсальный «закрыватель» блока операторов. Кроме того операторы отделяются друг от друга простым пробелом. Можно их для читаемости разделять символом перевода строки или точкой с запятой, но никто специально вас так делать не заставляет, вполне можно было бы написать так:

<code lang='lua'>
function hworld() print('Hello world!') end

function many_bottles(n) for i = 1, n do print('Осталось ' .. i .. ' бутылок пива.') end end

function many_bottles1(n) for i = 1, n do print('Осталось ' .. i .. ' бутылок пива.'); end; end
</code>

Всё это корректный код на Lua. Впрочем, это не означает, что так надо писать =) Думайте о читабельности. (Хотя признаюсь, иногда пишу такие однострочники, в основном для описания лямбда-функций, которое передаю в качестве колбеков.)

<b>Итог:</b>

Мы познакомились с основными операторами: объявления функции (function name(args) ... end), циклов (<b>for counter = from, to[, step] do ... end</b>, <b>while cond do ... end</b>, <b>repeat ... until cond</b>) и условий (<b>if/elseif/else/end</b>). Кроме того узнали операции конкатенации (<b>..</b>) и неравенства (<b>~=</b>), отличающиеся от аналогичных в большинстве других языков (остальные все такие же, как в C), познакомились с парой функций из стандартного модуля <b>io</b> (<b>io.read(what)</b> и <b>io.write(data)</b>), константами <b>true</b>, <b>false</b> и <b>nil</b> и одной особенностью булевых операций языка (любое определённое значение является истиной, даже ноль и пустая строка).

В следующей части расскажу про структуры и типы данных.

WeLinuxLua2
