
<<TableOfContents()>>

== ACL ==

=== Права на объект ===

Основные тезисы.

    1. Права на объект выделяются на группу и операцию. Группы не зависят друг
       от друга и не образуют некой неявной (захардкоженой или следующей из
       некой заранее определённой логики приложения) иерархии при назначении на
       них прав, хотя и могут явно быть подгруппами друг друга. ~-Последнее
       фактически означает, что пользователи, входящие в группу ''B'',
       одновременно автоматически входят в группу ''A'', которая является
       родительствой для группы ''B''.-~

    2. Права состоят из следующих битовых масок, по биту на операцию:
        * ''u_mask'' — пользовательские права, которые пользователь сам ручками
        установил на объект,
        * ''e_mask'' — эффективные права, которые сама система определила
        исходя из своих собственных внутренних факторов (описаны ниже) на
        основе ''r_mask''.
    
    3. Права могут кешироваться в любых модулях, при этом достаточно
       кеширования эффективных прав (поля `e_mask`). Схема кеширования может
       отличаться в различных случаях и зависит от реализации. Основные
       критерии здесь (1) быстродействие и (2) актуальность, при этом
       быстродействие на первом месте. В особо критичных участках проекта
       возможен полный или частичный отказ от ACL либо выбор альтернативной
       методики определения прав, отличной от описываемой здесь. Возможные
       схемы кеширования рассмотрены в соответствующем разделе ниже.
    
    4. Таблица ACL связывает объект с группой по маске прав, то есть составляет
       такую таблицу:

       || '''object_id''' || id объекта, на который выделены права       ||
       || '''group_id'''  || id группы пользователей, которой даны права ||
       || '''u_mask'''    || маска пользовательских прав                 ||
       || '''e_mask'''    || маска эффективных прав                      ||

       Каждая операция имеет свой бит и соответствующую битовую маску,
       установленный в поле `e_mask` бит, соответствующий данной операции,
       означает, что у пользователя в данной группе `group_id` имеется права на
       эту операцию над объектом `object_id`.
    
    5. Не следует путать группы пользователей и права. Например в случае с
       сообществами есть группа «Администраторы», которой выдаются права на
       администрирование сообществом, но существование такой группы вовсе не
       означает, что группа «Администраторы» является администраторской группой
       просто в силу своего существования и обладания таким именем, мы тем же
       успехом могли бы выдать права на администрирование любой другой группе,
       хоть «Гостям» (и тогда члены группы «Гости» стали бы администраторами
       данного сообщества). С другой стороны можно бы и отобрать права на
       администрирование у группы администраторов. Названия групп по сути нужны
       для удобства, а решающую роль играют именно права, этим группам
       выданные.
    
    6. Возможно создание анонимной группы пользователей, закреплённой за данным
       конкретным объектом, в который будут включены выбранные пользователем
       люди. Таким образом реализуются кастомные «белые списки» в стиле «…а ещё
       смотреть пост могут выбранные мной люди». Такая группа на объект может
       быть только одна и создаётся только в момент пожелания пользователя
       создать такой кастомный список.
    
    7. Возможно также существование специальных групп без владельцев, таких как
       «Администраторы Unite», «Все пользователи», «Все зарегистрированные».
    
    8. Группы «Все» и «Все зарегистрированные» особые. Выбор прав для любой
       группы, отличной от этих двух, приводит к отмене прав для этих групп.
       Выбор прав для одной из этих групп означает автоматическое включение
       этих прав для всех групп (фактически это право можно от всех групп
       физически забрать, т.к. оно с этого момента у них подразумевается). В
       группу «Все зарегистрированные» входят все пользователи Unite, в группу
       «Все пользователи» входят все пользователи, как известные системе, так и
       не зашедшие в неё.

Права на объект проверяются всегда по ''e_mask'', пользователь же при правке
объекта видит только права по ''u_mask''.

Пользовательские права выставляются самим пользователем в момент создания или
изменения конкретного объекта. Именно они являются __прямым желанием пользователя__
по права объекта.

Эффективные права устанавливаются самой системой при изменении прав контейнера
данного объекта с применением побитового ''и'' с реальной маской каждого
элемента контейнера. Они являются теми правами, которые __система реально выдала__
на объект.

    ~-Например есть блог и посты в нём с такими правами (эффективные и
    пользовательские равны, т.к. только что установлены):

        * Блог — видеть могут все,
            * Пост 1 — видеть могут только друзья,
            * Пост 2 — видеть могут все.

    Теперь предположим, что владелец изменил права блога на видимость только
    для друзей. Полчаем следующую картину:

        * Блог — видеть могут только друзья,
            * Пост 1 — видеть могут только друзья,
            * Пост 2 — видеть могут только друзья (пользовательские права —
            видеть могут все).

    Если теперь юзер вернёт права на блог для всех, то будет такая картина:

        * Блог — видеть могут все,
            * Пост 1 — видеть могут только друзья,
            * Пост 2 — видеть могут все (пользовательские права → эффективные
            права).-~

Таким образом в эффективных правах хранятся права, которые
    1. выставились системой с учётом прав на контейнер (и, возможно, каких-либо
       иных соображений системы);
    2. будут использоваться системой везде, где нужно определить права
       пользователя на совершение данной операции над объектом,
    3. будут кешироваться в различных подсистемах (по мере необходимости).

Пользовательские права
    1. видны пользователю в настройках объекта, как те, что он сам назначил;
    2. используются как своеобразный «бекап» при «восстановлении» прав на
       объект;
    3. используются как база для сравнения с явными желаниями пользователя.

<<Anchor(idea1)>>[[#idea1]] В самом интерфейсе изменения прав на объект можно
выделять (например цветом) те группы, права на которые изменены в эффективной
маске, чтобы юзер мог явно их разрешить для этого объекта в обход родительских
прав.

=== Алгоритм установки прав ===

Установка прав возможна на
    1. элемент контента (пост в блоге, фотка в альбоме и т.д.),
    2. контейнер элементов контента (блог, альбом и т.д.),
    3. владельца элемента (сообщество или профиль).

Установка пользовательских прав на любой объект происходит безусловно при
выборе этих прав пользователем (возможны ограничения выбора в соответствии с
бизнес-логикой, но пользовательские права всегда те, что пользователь указал
при правке объекта).

Соответственно взаимовлияние эффективных прав на эти объекты и соответствующие
алгоритмы установки эффективных прав на них возможны следующие.

==== Установка прав на элементы контента ====

    1. Установка прав на элемент контента устанавливает эффективные права,
       равные пользовательским правам ~-(это поведение сейчас выбрано
       коллегиально)-~.
    2. Установка прав на элемент контента устанавливает эффективные права,
       равные пользовательским правам, объединённым с правами его контейнера
       через побитовое ''и''.

Группы, доступные для установки прав на элемент контента, могут быть ограничены
группами, выбранными в контейнере или владельце объекта (для данной операции).

==== Установка прав на контейнеры ====

Установка прав на контейнер может влиять на установку эффективных прав
содержащихся в нём элементов, и испытывать влияние владельца контейнера.

Возможные алгоритмы влияния установки прав на контейнер на права его элементов:

    1. Установка прав на контейнер влечёт за собой установку эффективных прав
       всех его элементов на эффективные права контейнера, объединённые через
       побитовое ''и'' с пользовательскими правами каждого данного элемента.
    2. Установка прав на контейнер влечёт за собой жёсткую установку
       эффективных прав всех его элементов на эффективные права этого
       контейнера.
    3. Как в варианте 2, но выставляются и пользовательские права на элементы
       контейнера.
    4. Установка прав на контейнер не влечёт за собой установку прав его
    элементов.

Вариант 2 очень неявный, т.к. реально пользователь не увидит изменения в правах,
а на элементы контейнера могут «просочиться» лишние права, поэтому я его дальше
не рассматриваю и упоминаю его в общем списке для полноты картины (может найдётся
для него адвокат).

Коллегиально был предложен вариант с пользовательским выбором между 1, 3 и 4
вариантами в виде «крыжиков».

<<Anchor(idea2)>>[[#idea2]] Я предлагаю немного другой вариант.

Установка прав контейнера без изменения прав на его элементы, ИМХО, очень
маловероятна (хотя я и могу представить себе такой сценарий, но я с трудом могу
представить, что мне захочется закрыть блог, оставив посты в нём доступными
публично). Поэтому опцию 4 предлагаю вообще не предлагать.

Опция 3 деструктивна по природе своей, т.к. исключает возможность какого угодно
восстановления заботливо выставленных на посты прав, поэтому это действие, хотя
и может быть востребовано пользователями, требует дополнительного
подтверждения. Поэтому я предлагаю сделать его не «крыжиком», а кнопкой с
надписью вроде «Сбросить права всех постов на права блога» и выводить
окно-подтверждение этого действия с описанием, что это действие сбросит все права
постов без возможности их быстро восстановить. И устанавливать права именно на те,
что были выбраны пользователем в окне правки блога на момент нажатия кнопки.

Если же пользователь не нажимал на эту кнопку, то всегда действовать по
варианту 1, как наиболее вероятно ожидаемому (по крайней мере ожидаемому мной
как достаточно опытным пользователем).

Возможные алгоритмы влияния на эффективные права контейнера во время установки
на пользовательских прав на него:

    1. Установка прав на контейнер вызывает установку эффективных прав на него
       равными пользовательским ~-(это поведение сейчас выбрано
       коллегиально)-~.
    2. Установка прав на контейнер вызывает установку эффективных прав на него
       равными пользовательским, объединённым с правами на владельца контейнера
       через побитовое ''и''.

==== Установка прав на владельцев ====

Фактически я буду рассматривать здесь права на сообщества.

Права на сообщества могут влиять на права объектов, в это сообщество входящих
(контейнеров и элементов контента) следующим образом:

    1. Установка прав на сообщество вызывает установку эффективных прав на все
       входящие в него элементы в эффективные права сообщества, объединённые
       через побитовое ''и'' с пользовательскими правами каждого такого элемента
       ~-(это поведение сейчас выбрано коллегиально)-~.
    2. Установка прав на сообщество приводит только к установке
       пользовательских и эффективных прав этого сообщества и не влияет на
       права его элементов.


=== Кеширование прав ===

    * TODO: предстоит до конца описать.

Пока что был предложен вариант хранить права в мемкеше в виде трёх таблиц:

    1. session_id → profile_id,
    2. profile_id → group_id,
    3. exists(group_id+object_id)?

Фактически нам нужно по сессии пользователя получить группы, в которые он входит.
Успех операции `op` или «отлуп» зависит от результатов поиска по сложному ключу
на шаге 3: если элемент найден, то права есть, если ошибка при поиске (элемента нет),
то и прав нет. Первые два шага позволяют преобразовать id сессии в список id групп
данного пользователя, которому сессия принадлежит.

Реально при этом варианте мы храним просто три таблицы с integer-ами:

    1. 4+4 = 8 байт/сессию,
    2. 4+4 = 8 байт/пользователя×группу,
    3. 4+4 = 8 байт/группу×объект.

Для примера пусть одновременных активных пользователей 1000 (1000 сессий),
тогда объём первой таблицы 8 000 байт. Пусть в системе 10 000 000 пользователей
и каждый в среднем состоит в 10 группах, тогда объём второй таблицы
8×10 000 000×10 = 80 000 000 байт. Пусть объектов с правами 100 000 000
(например, каждый юзер написал в среднем по 10 постов в блогах) и на каждый
объект выделено прав на просмотр в среднем на 10 групп, тогда объём третьей
таблицы 8×100 000 000×10 = 8 000 000 000 байт.
Итого 8 000 + 80 000 000 + 8 000 000 000 = '''8 080 008 000''' байт или
примерно '''7,5 Гб''', что в общем-то не так уж и много =)


