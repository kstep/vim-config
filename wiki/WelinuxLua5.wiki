Введение в Lua для программистов — часть 2.3

<a href="http://welinux.ru/post/5196/">Немного раньше</a> я показал работу с функциями. Теперь я расскажу о типах <b>userdata</b> и <b>thread</b>, а так же затрону тему области видимости переменных.

[cut]

<h1>Франшиза</h1>

Тип данных <b>userdata</b> стоит несколько особняком. По сути это аватар произвольной C-структуры в мире Lua. Или, если угодно, своеобразная франшиза, бренд, под которым в Lua видны кастомные типы данных. Строго говоря нет такого одного отдельного типа данных — <b>userdata</b>, есть множество различных разнородных кастомных типов данных, которые создаются либо в C-библиотеках, либо в хост-приложении, которое пользует Lua (не забываем, что Lua очень часто используется не как самостоятельный интерпретатор, а как библиотека, прилинкованная к «большому» приложению, и вот это приложение может создать произвольное окружение для выполняемых в его рамках Lua-скриптов; оно и будет хостом для Lua-программ). В Lua все такие кастомные типы (обычно это C-шные <b>struct</b>-ы, но это необязательно) видны как один тип — <b>userdata</b>, хотя и природа данных под этим типом может быть совершенно разная.

Примером типа <b>userdata</b> может, например, послужить объект <b>screen</b> в Awesome:

<code lang='lua'>
$ awesome-client
awesome# return screen[1]
    string "userdata: 0x9eb54d0"
awesome# return type(screen[1])
    string "userdata"
</code>

В данном случае хост-приложение Awesome передаёт в Lua-окружение специальную таблицу-массив <b>screen</b>, элементы которых содержать объекты, представляющие физический экран. Хотя внешне эти элементы видны как объекты типа <b>userdata</b>, фактически это объекты типа <b>screen</b>, предоставляющие интерфейс к физическому экрану: его разрешение, рабочую область за вычетом зон, занятых виджетами самого WM и порядковый номер экрана. Точно так же Awesome определяет несколько других типов данных в Lua для манипуляции с запущенными приложениями, изображениями и т.д. Подробнее можно про этот зоопарк почитать в <a href="http://awesome.naquadah.org/doc/api/index.html">официальной документации</a>.

Таким образом <b>userdata</b> является собирательным образом всех кастомных типов, которые для Lua предоставляет C-часть, поэтому описывать его практически невозможно: нужно брать конкретную реализацию, библиотеку, смотреть конкретные типы данных и читать про их интерфейс, методы и свойства, которые они определяют. Созать такой кастомный тип средствами самого Lua невозможно, да, как правило, и не нужно.

<h1>Клубок нитей</h1>

Lua поддерживает исполнение кооперативных потоков, для этого есть специальная библиотека <b>coroutine</b>. Если честно я сомневаюсь, стоит ли рассказывать сейчас про все её фичи, потому что сопрограммы и мультритрединг (в любом виде, в том числе и кооперативный) — это тема отдельной большой статьи, которую я ещё напишу. Поэтому здесь я просто упомяну, что такая библиотека есть, а тем, кому не в терпёж, (и позволяет теоретическая и практическая подготовка) могут прочитать про неё в документации к Lua прямо сейчас. Если кратко, то объекты типа <b>thread</b> создаются функциями из библиотеки <b>coroutine</b>, представляют один поток выполнения и предоставляют интерфейс для манипуляции с этим потоком.

<h1>Ветер переменных</h1>

А теперь так же кратенько о переменных. Переменные по области видимости в Lua делятся на локальные и глобальные. Все переменные, которые создаются в программе, являются глобальными, если особо не заявлено обратное:

<code lang='lua'>
-- создаём переменную b
b = 10

-- здесь изменяется переменная b
function setb()
    b = 20
end

-- здесь изменяется переменная a
function seta()
    a = 30
end

-- выведет nil и 10
print(a, b)
seta()
setb()
-- выведет 30 и 20
print(a, b)
</code>

Как видите обе переменные a и b глобальны, хотя вне тела функции создана только переменная b.

Локальные переменные объявляются с помощью ключевого слова <b>local</b>, закрывая по необходимости глобальные переменные с теми же именами:

<code lang='lua'>
function seta()
    -- здесь a пока что глобальная
    print("before local", a)
    a = 20
    
    -- а здесь она локальная
    local a
    print("after local", a)
    a = 30
    print("after local assignment", a)
end

-- глобальная a
a = 10

-- выведет 10
print(a)

--[[ выведет:
before local 10
after local nil
after local assignment 30
]]
seta()

-- выведет 20
print(a)
</code>

Оператор <b>local</b> действует в пределах текущего блока операторов, при этом действие его начинается в момент определения переменной с этим ключевым словом (как видно в примере функция <i>seta()</i> могла модифицировать глобальную переменную до тех пор, пока она не была перекрыта локальной, объявленной оператором <b>local</b>).

Кроме того можно совместить присваивание переменной значения с её объявлением через <b>local</b>.

Локальные переменные могут быть созданы не только в пределах функции, но и в пределах любого блока операторов:

<code lang='lua'>
somevar = 10

-- локальная переменная в if-е:
if true then
    local somevar = 20
    print(somevar) -- выведет 20
end

-- локальная переменная в for:
for i = 1, 40 do
    -- если остаток от деления i на 2 равен нулю (число чётное),
    if i % 2 == 0 then
        -- то пропустить итерацию
        continue
    end

    local somevar = i + 10

    -- выведет нечётные числа от 11 до 49
    print(somevar)
end

-- локальная переменная в while-е:
while true do
    local somevar = 30
    print(somevar) -- выведет 30

    break -- превентивный выход из цикла
end

-- выведет 10
print(somevar)
</code>

Если хочется локальной переменной только в некотором куске кода, и не хочется объявлять циклов и функций, то можно воспользоваться универсальными операторными скобками <b>do ... end</b>:

<code lang='lua'>
othervar = 100

do
    local othervar = 50
    -- будет 50
    print(othervar)
end

-- будет 100
print(othervar)
</code>

Локальными могут быть и функции, ведь объявление функции это всего навсего присваивание объекта типа функция некоторой переменной:

<code lang='lua'>
function outer()
    -- то же, что и 
    -- local inner = function() end
    local function inner()
    end
    print(inner)

    function inner2()
    end
end

-- выведет что-то вроде function: 0x934da48
-- (функция inner)
outer()

-- функция inner не попадёт в глобальную область видимости:
-- выведет nil
print(inner)

-- но функция inner2 будет видна снаружи:
-- выведет что-то вроде function: 0x934d610
print(inner2)
</code>

Локальные переменные имеют лексическую область видимости:

<code lang='lua'>
a = 10
function geta()
    print(a)
end

function seta()
    local a = 20
    geta()
end

-- выведет 10, потому что локальная a из seta()
-- лексически заперта в функции seta(), так что geta()
-- увидит только глобальную a.
seta()
</code>

(Динамическое связывание переменных можно эмулировать через заворачивание функции в другую функцию, которая сохраняет в своей локальной переменной необходимые глобальные переменные, назначает им новые значения, вызывает первую функцию и восстанавливает глобальные переменные из локальной копии. Это ни разу ни thread-safe, так что использовать нужно с умом. Подробнее этот и другие хаки описаны <a href="http://lua-users.org/wiki/LuaHacks">здесь</a>.)

Естественно все параметры функции автоматически являются локальными для этой функции. Кроме того, локальные переменные могут попадать в замыкания (пример смотрите в конце <a href="http://welinux.ru/post/5196/">предыдущей статьи</a>).

<b>Итог:</b> мы наскоро познакомились с двумя последними типами данных — <b>userdata</b> и <b>thread</b>, узнали про локальные переменные (которые объявляются оператором <b>local</b> и имеют лексическую область видимости) и универсальный операторный блок <b>do ... end</b>. Кроме того внимательных читателей ожидал бонус в виде операторов <b>break</b> и <b>continue</b> для досрочного выхода из цикла и досрочного перехода к следующей итерации цикла.

В следующей статье я хочу устроить интерлюдию, в которой собираюсь привести пример рабочей программы на основе уже изложенного материала. Какой именно пример показать я пока ещё не придумал, поэтому у читателей есть шанс предложить свои варианты. Или может у кого уже есть какие-то наброски по тексту статей? Идеи прошу в комменты!

