Про качество, цену и ценность.

Чем лучше вещь, тем меньше на нёй заверений в её качестве, вроде «приемиум», «нью», «супер-пупер» и т.д.
Самые лучшие вещи лишены этикеток: сама вещь, сам её вид всё говорит за неё.
Производители лучших вещей не боятся, и потому не борятся, за свои «авторские права»: подделать, содрать, повторить такую вещь под силу только настоящему мастеру, а настоящие мастера заняты созданием своих лучших вещей, им не до мелких подделок.
И настоящий, ценящий покупатель не будет покупать подделку, а другие покупатели создателю лучших вещей не нужны.

Совершенные мастера слишком заняты процессом творения, у них нет времени на разглагольствования.
И только те, кто делает дерьмо, воняют о своих правах больше всего.

------
Равенство

Люди не равны. Пора бы уже это понять и признать.

Доказательство просто: любое заявление о равенстве всех приводит к ярым попыткам уличённых в равенстве людей
доказать свою непохожесть и исключительность.

Это свойство человека: пытаться забраться как можно выше других и не дать это сделать другим. Сама человеческа природа
против равенства. Скажи первому встречному, что он такой же, как и все, и он, в силу своего морального и интеллектуального уровня, попытается убедить тебя в обратном (от развязывания философской дискуссии, до банального «щас в глаз дам»).

Люди не равны.

------

Келен и Ричард видят очередной город.

Жители города:
— Искатель! Помоги нам! Нас убивают!

Ричард:
— О, я вижу странные следы! Тут твориться какая-то Страшная Фигня!

Келен:
— Используй свой дар Искателя, Ричард!

Ричард:
— Наверняка тут использовали какую-то Страшно Сильную Тёмную Магию!

Повстанцы из леса:
— Тут недалеко форпост Рала! Наверняка Страшно Сильная Тёмная Магия оттуда!

Ричард и Келен идут в форпост Рала, Очень Храбро сражаются, их хватают.

Капитан войск Рала:
— Я схватил Искателя! Меня наградят!

Морд-Сид:
— Я всех веду к Ралу!

Появляется Зед, освобождает Ричарда и Келен, они вместе мочат солдат Рала и сбегают вместе со Страшно Сильной Тёмной Магией.

Ричард:
— Мы можем использовать Страшно Сильную Тёмную Магию против Рала!

Зед:
— Нет, Ричард, она поработит тебя. Её нужно спрятать, чтоб никто не нашёл!
Уходит вместе со Страшно Сильной Тёмной Магией.

Ричард:
— Келен, я люблю тебя!

Келен:
— Ричард, я тоже люблю тебя, но нам нужно выполнять нашу Миссию!

Ричард и Келен уходят в лес.

Краткое содержание большинства серий «Легенды об Искателе».

= Статья для welinux =

У меня иногда так бывает, что после разбора завалов в домашнем каталоге и
перемещения файлов на новые более логичные для них места, требуется
восстановить поломанные ссылки на эти перемещённые файлы.
Чтобы не делать этого ручками, набросал три скрипта: один на перле и два на
шелле.

[cut]
<i>Статья написана в том числе для начинающий программистов, с подробными
объяснениями алгоритмов, принятых и применённых решений в спойлерах.</i>

Итак, декомпозиция задачи на три:
1) Найти все битые ссылки,
2) Для заданной ссылки найти места, где может находится «потерянный» ссылкой файл,
3) Починить ссылку, переписав её местоназначение.

Программистские подробности об алгоритмах и тонкостях реализации в спойлере,
если кому интересно:
<spoiler>
Самый сложный шаг №2. Для него был разработан такой алгоритм (и воплощён в
перле, т.к. на шелле такое сделать довольно сложно):
1) Разбить полный путь к «потерянному» (ныне несуществующему) файлу на имя
файла (basename) и каталог (путь к файлу без самого файла, dirname),
2) Разбить путь к файлу на компоненты-каталоги и найти первый каталог в этой
цепочке, который реально отсутствует, таким образом все каталоги до этого
каталога существуют в системе. Это та точка, из которой будет вестись поиск,
назовём её guessed_dir.
3) Найти все файлы с заданным именем (basename) рекурсивно в подкаталогах
guessed_dir.
4) Если файлов в шаге 3 не найдено, поднимемся на каталог выше guessed_dir
(guessed_dir = guessed_dir/..) и повторим шаг 3.
5) Останов.

В результате выполнения этого алгоритма находится файл с заданным именем, если
он был перемещён практически в любое место файловой системы, причём поиск будет
очень быстрым, т.к. в первую очередь будет щупаться самая узкая область:
предполагается, что файл был перемещён в пределах самого узкого существующего
каталога, а расширяться область поиска будет только в том случае, если файл был
перемещён куда-то выше.

На деле я использую небольшую модификацию этого алгоритма:
1) я оптимизирую поиск при поднятии на каталог выше, исключая из поиска уже
проверенные более «узкие» каталоги,
2) я не останавливаюсь на первом найденном файле, стараюсь найти как можно
больше вариантов и даю юзеру (то есть себе, любимому =) как можно больше
вариантов для выбора и корректного восстановления файлов.
</spoiler>

Теперь к делу.

1) Найти все битые ссылки.
Скрипт fixlinks:
<code lang='bash'>
#!/bin/sh

if test "$1" = "help"; then
    cat <<EOD

Чинит все поломанные ссылки в заданном каталоге и всех его подкаталогах.

Вызов:
    fixlinks [path/to/dir]

Результат:
    Находит все поломанные ссылки в заданном каталоге и всех его полкаталогах
    (по умолчанию поиск из текущего каталога) и пытается угадать новое размещение
    файла, на который указывает каждая ссылка.
    Для каждой поломанной ссылки юзеру будет предложен нумерованный список найденных
    файлов, которые удалось обнаружить, и юзер сможет либо указать, номер файла
    для полинки ссылки, либо 0 (или любую другую последовательность нецифровых символов),
    чтобы отменить починку этой ссылки и продолжить поиск.

Требует нахождения скриптов fixlink и guess в одном с собой каталоге.

EOD
    exit
fi

FIXER="`dirname $0`"/fixlink
BASEDIR="$1"
test -n "$BASEDIR" || BASEDIR="."
test -d "$BASEDIR" || exit

find "$BASEDIR" -type l -exec "$FIXER" {} \;
</code>

2) Для заданной ссылки найти места, где может находится «потерянный» ссылкой файл.
Скрипт guess, сердце всего решения:
<code lang='perl'>
#!/usr/bin/perl

use strict;

# 1. Получим само исходное имя
my $fullname = $ARGV[0];
unless ($fullname)
{
    print <<EOD

Пытается догадаться о новом расположении файла по заданному полному пути к файлу,
если этот файл уже отсутствует по этому пути.

Вызов:
    guess /full/path/to/non/existing/file/name

Результат:
    Выводит нумерованный список найденных файлов на STDERR и спрашивает у юзера
    номер файла. Если юзер укажет номер файла, то выведет его имя на STDOUT,
    иначе (если юзер укажет 0 или любую нецифровую строку) не выведет ничего.

Удобно использовать в скриптах, например для починки поломанных ссылок.

EOD
    exit;
}

exit if -e $fullname;

# 2. Разобъём на имя файла и имя каталога
my ($basename) = ($fullname =~ /([^\/]+)$/);
my ($dirname) = ($fullname =~ /^(.+)\//);

# 3. Имя каталога очистим и разобъём на компоненты
$dirname =~ s/^\/+//;
$dirname =~ s/\/+$//;
my @dirparts = split /\//, $dirname;

# 4. Найдём первый несуществующий каталог в цепочке компонентов пути
my $existing_dir = "";
my @existing_dir = ();
foreach my $dirpart (@dirparts)
{
    last unless -d "$existing_dir/$dirpart";
    $existing_dir .= "/$dirpart";
    push @existing_dir, $dirpart;
}

# 5. Ищем данный файл в поддереве
my %guessed_dirs = ();
my @guessed_files = ();
my $num = 0;
for (; @existing_dir; pop @existing_dir)
{
    my $guessed_dir = "/" . join("/", @existing_dir);
    my $guessed_file = guess_file($guessed_dir, $basename, \%guessed_dirs);
    if ($guessed_file)
    {
        printf STDERR "%d) %s\n", ++$num, $guessed_file;
        $guessed_dirs{$guessed_dir} = 1;
        push @guessed_files, $guessed_file;
    }
}

if ($num > 0)
{
    my $chosen_file;
    do {
        print STDERR "Choose filename to fix, 0 to cancel: ";
        $chosen_file = 0+<STDIN>;
    } until ((0 <= $chosen_file) && ($chosen_file <= $num));
    exit unless $chosen_file;
    print $guessed_files[$chosen_file-1];
}

sub guess_file
{
    my ($dir, $file, $ignore_dirs) = @_;
    return "" if exists($ignore_dirs->{$dir});
    my $wildguess = "$dir/$file";
    return $wildguess if -e $wildguess;
    foreach my $subdir (glob("$dir/*"))
    {
        next unless -d $subdir;
        my $afile = guess_file($subdir, $file, $ignore_dirs);
        return $afile if $afile;
    }
    return "";
}
</code>

3) Починить ссылку, переписав её местоназначение.
Скрипт fixlink, промежуточная связка между fixlinks и guess:
<code lang='bash'>
#!/bin/sh

if test -z "$1"; then
    cat <<EOD

Чинит заданную символьную ссылку, если файл, на который эта ссылка указывает,
уже куда-то перемещён.

Вызов:
    fixlink sym/link/name

Результат:
    Попытается угадать новое местоположение файла, на который указывает ссылка,
    и предлагает юзеру выбрать один из найденных файлов. Юзер может либо ввести
    номер найденного файла, чтобы починить ссылку, либо ввести 0 или другую
    нецифровую последовательность символов, чтобы отказаться от починки ссылки.

Утилита требует наличия перлового скрипта guess в одном с ней каталоге.

EOD
    exit
fi

LINKNAME="$1"
GUESSER="`dirname $0`/guess"
REALNAME="`readlink -m $1`"

test -e "$REALNAME" && exit 0

echo; echo "Link $LINKNAME points to non-existing file $REALNAME, guessing..."
GUESS="`$GUESSER \"$REALNAME\"`"
test -n "$GUESS" && ln -sf "$GUESS" "$LINKNAME"
</code>

Резюме для начинающих программистов в спойлере.
<spoiler>
1) Учимся декомпозировать задачу и выбирать средства реализации.

Часто оказывается, что каждую мелкие простые подзадачи легче всего решаются на
разных языках. В этом примере части, связанные с поиском файлов и перепрошитием
ссылок, легче всего решить шелловскими утилитами вроде find и ln, поэтому они
реализованы на shell, в то время, как задача по поиску и «догадыванию» нового
имени файла достаточно сложная и её проще было решить на более сложном и полном
языке; в моём случае я выбрал perl.

2) Учимся упрощать.

Скрипту на perl передаются очищенные данные: полностью корректный
полный путь к несуществующему файлу, полученный с помощью «readlink -m».
Сделать то же самое средствами чистого перл было бы сложнее, поэтому я этой сложности
избежал, водрузив эту работу на инструменты, изначально для этого предназначенные.
This is a true unix-way!

3) Учимся расширять знания на основе уже имещихся.

Раньше я не знал, что у readlink есть ключ «-m», который преобразует
относительный путь, вычитанный в символьной ссылке, в полный корректный путь,
разворачивая «.» и «..», без наложения необходимости существования на каждый
элемент пути. Однако я знал о существовании команды readlink, и знал, что мне
нужно получить полное имя файла по ссылке на него. Дальнейшее решение было
получено чтением мануалов по readlink. Если бы этой опции не было, пошёл бы
копать в сторону basename/dirname, в гугл пошёл бы в конце концов. Учитель
опираться на существующие знания и получать новые для достижения чётко
поставленной цели: чем чётче цель, тем больше шансов найти решение за краткие
сроки!

4) Учимся документировать.

После написания каждого скрипта, к ним была написана справка по пользованию для
простого юзера. Это действительно важно, и не только если вы собираетесь
распространять скрипты другим людям, но и для себя. Предтавьте себя через
неделю, месяц, год... Вы уже забыли, что и как было написано, но вот встала
такая я же или похожая задача. Всё, что вы помните, это то, что когда-то для
решения этой задачи написали какие-то скрипты. А задачу надо решить быстро, и
нет времени вспоминать, как и что вы писали год назад и где эти скрипты лежат.
Если бы справки не было, вы бы даже если и нашли эти скрипты, то потратили бы
кучу времени, вспоминая, что и как было сделано и как это пользовать. Но вы
написали справку! И теперь эти скриптики мало того, что можно в крайнем случае
склероза найти полнотекстным поиском по файлам по ключевым словам «ссылки,
починить» (да тем же грепом, в конце концов), но и воспользоваться ими сможете,
что называется, с места в карьер: прочитали краткую справку и запустили
скрипты, не вдаваясь в подробности реализации.
</spoiler>
