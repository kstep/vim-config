
Диалект !PostgreSQL SQLAlchemy к сожалению не поддерживает (или поддерживает слабо) некоторые операции, специфичные для !PostgreSQL:

    1. Индексы по выражениям и индексы с нестандартных типов (`GIN`, `GiST`),
    2. Почти все функции для работы с массивами чисел (например `uniq()` и `sort()`),
    3. Практически все операторы для работы с массивами, вроде включения и пересечения (`@@`, `@>`, `<@` и т.д.),
    в частности нужный мне оператор `@@` для сравнения массива с query_int выражением (`'{1,2,3}'::int[] @@ '1|2'::query_int`).

В связи с этим я сделал наше собственное дополнение к диалекту SQLAlchemy !PostgreSQL, которое в дальнейшем можно расширять по мере необходимости.

Это дополнение содержится в модуле `unite.lib.pgdialect` (файл `unite/lib/pgdialect.py` соответственно):

Примерно следующий код используется в функции `init_model` из `unite.model` для инициализации диалекта:
{{{
#!python
from unite.lib.pgdialect import install_dialect
install_dialect()
}}}

После этого в объектах SQLAlchemy подменяются некоторые методы, обеспечивающие корректную работу с нашим диалектом (по другому, увы, не получилось).

Эта функция реально устанавливает (и перекрывает) два метода в структурах SQLAlchemy:

    1. `PGSchemaGenerator.visit_index` для работы с расширенным классом Index с поддержкой индексов по выражениям и нестандартных типов индексов,
    2. новый метод `Column.has()` для оператора сравнения массивов с выражением query_int `@@`.

Кроме того в диалекта определены некоторые новые SQL-функции для работы с массивами в !PostgreSQL.

Рассмотрю поподробнее каждый из этих пунктов.

== Расширенный класс Index ==

После установки диалекты становятся возможным следующие операции при создании индексов:

{{{
#!python
from sqlalchemy import Index
gin_index = Index('some_name', table.c.acolumn, using='GIN', opclass=('gin__int_ops',))
gin_index.create()

expr_index = Index('some_other_name', cls.col1, cls.col2, expr=cls.col1.op('||')(cls.col2))
expr_index.create()
}}}

В первом случае создаётся индекс для поля типа массив чисел (`integer[]`) с типом `GIN`.
Параметр `using` определяет тип индекса (`GIN` или `GiST`), параметр `opclass` определяет классы операторов для каждой колонки, указанной в индексе. Если `opclass` вообще указан, то он должен быть списком или кортежем с числом элементов, равным числу колонок в индексе, все элементы в нём должны быть строками (или приводится к ним) с указанием класса операторов для каждой данной колонки. Если для какой-либо колонки не нужен кастомный класс операторов, то надо в соответствующей позиции `opclass` указать пустую строку `''`.

Во втором случае создаётся индекс по выражению, указанному в параметре `expr`. По идее в !PostgreSQL можно указывать выражения для индексации наравне с отдельными колонками, так что логично было бы сделать как-то вот так:

{{{
#!python
expr_index = Index('some_other_name', cls.col1.op('||')(cls.col2))
}}}

Но объект `Index` требует указания хотя бы одной колонки в списке `*args`, иначе он просто не сможет нормально связать индекс с конкретной таблицей (таблица для индекса берётся из объектов-колонок, указанных при создании объекта класса `Index`), поэтому на данный момент можно строить индекс только по одному выражению, указанному в параметре `expr`, но при этом необходимо указать хотя бы однку колонку, связанную с таблицей для индексации.

Таким образом на данный момент получается, что если у индекса указан параметр `expr`, то индексация проводится по заданному этом параметре выражению, а колонки полностью игнорируются и используются только для указания таблицы, по которой строится индекс.

Про `GIN` и `GiST` индексы, индексы по выражениям и классы операторов можно почитать доку !PostgreSQL:

    * http://www.postgresql.org/docs/8.3/static/textsearch-indexes.html
    * http://www.postgresql.org/docs/8.3/static/sql-createindex.html
    * http://www.postgresql.org/docs/8.3/static/indexes-opclass.html
    * http://www.postgresql.org/docs/8.3/static/xindex.html

== Дополнительные функции и операторы ==

В модуле `unite.lib.pgdialect` описаны следующие дополнительные функции:

    * `uniq(integer[])` — возвращает `integer[]`, удаляет все повторяющиеся ''рядом стоящие'' элементы массива,
    * `sort(integer[])` — возвращает `integer[]`, сортирует массив по возрастанию,
    * `all_uniq(integer[])` — возвращает `integer[]`, комбинирует `uniq()` и `sort()` для реального удаления дублированных элементов массива (то есть в !PostgreSQL пойдёт конструкция вида `uniq(sort(:var))`),
    * `agg_array_cat(integer[])` — агрегирующая функция, возвращает `integer[]`, собирает массивы (колонки типа массив) в один,
    * `agg_array_append(integer)` — агрегирующая функция, возвращает `integer[]`, собирает числа в один массив.

Кроме того для класса `Column` определён новый метод-оператор `has()`, который принимает единственный параметр (число, строку, список, кортеж или множество). Служит для построения запросов вида `sometable.c.array_column.has(5)`. !PostgreSQL при этом получает выражение вида `array_column @@ '5'::query_int`. Этот оператор проверяет соответствие данного массива данному запросу. Если в качестве параметра передаётся список/кортеж/множество, то требуется наличие всех его элементов в данном массиве (операция «и»), если число — то проверяется, что это число есть в массиве, если строка, то в ней может быть любое кастомное выражение, приводимое к типу `query_int`.

Примеры:

{{{
#!python
tbl.c.acol.has(5) # колонка содержит число 5,
tbl.c.acol.has([1,3]) # колонка содержит числа 1 и 3,
tbl.c.acol.has('1|3') # колонка содержит либо число 1, либо число 3, либо оба этих числа,
tbl.c.acol.has('5&(1|3)') # колонка содержит число 5 и хотя бы одно из чисел 1 или 3.
}}}

Эта операция работает только для массивов целых чисел (`integer[]`).
По идее её можно было бы переопределить для метода-оператора `match()` для конкретного типа `PGArray(Integer)`, но SQLAlchemy позволяет это делать только для ограниченного числа арифметических операторов, вроде `+`, `-`, `/` и `*`, поэтому я добавил оператор с новым именем, чтобы избежать конфликтов с уже существующими.

Подробнее про массивы, операторы и функции, описанные в этом разделе, можно почитать в доке !PostgreSQL:

    * http://www.postgresql.org/docs/8.3/static/functions-array.html
    * http://www.postgresql.org/docs/8.3/static/arrays.html
    * http://www.postgresql.org/docs/8.3/static/intarray.html

== Новый кастомный класс-тип PGIntarray ==

Для лучшей поддержки типа данных !PostgreSQL `integer[]` (представленного в SQLAlchemy конструкцией `PGArray(Integer)`) я ввёл свой класс-тип `PGIntarray`. В частности это сделано потому, что многие вещи в !PostgreSQL для типа `integer[]` работают несколько иначе, чем для остальных типов-массивов.

Использование:

{{{
#!python
from unite.lib.pgdialect import PGIntarray
table = Table('some_table_name', meta,
    Column('some_col_name', PGIntarray), # массив чисел, в питоне представляется простым списком (list()),
    Column('other_col_name', PGIntarray(set)) # массив чисел, в питоне представляется множеством (set()).
    )
}}}

Основные, и пока единственные, отличие от обычного `PGArray(Integer)`:

    * тип элементов жёстко прошит, это всегда `Integer`,
    * вместо этого в качестве первого (и единственного) параметра при инициализации этого объекта можно указать класс для хранения коллекции чисел с точки зрения питона (для !PostgreSQL это всегда будет массив). Это может быть любой класс, свободно итерируемый и, таким образом, приводимый к типу `list`, например `set` или `tuple`, но НЕ `dict`. По-умолчанию это простой список (`list`),
    * кроме того этот класс служит как маркер, однозначно определяя конкретно тип `integer[]` для настоящих (и будущих) функций и методов, определённых в модуле `unite.lib.pgdialect` (а может в будущем и не только в нём).
