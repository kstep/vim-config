Введение в Lua для начинающих программистов — часть 2

<a href="">Предыдущая статья.</a>

В этой части я расскажу о типах данных в Lua и основных операциях с ними.

[cut]
Как я уже упоминал ранее, Lua — язык с динамической слабой типизацией. Это означает, что все переменные создаются на лету при первом присваивании им некоторого значения, а их тип опрделяется тем значением, которое им присваивается, более того, типы приводятся один к другому неявно (хотя при необходимости можно сделать явное привидение типов, но это нужно гораздо реже, чем в других языках).

Типы данных в Lua бывают следующие:

<ul><li>nil,</li><li>number,</li><li>string,</li><li>boolean,</li><li>function,</li><li>table,</li><li>userdata,</li><li>thread.</li></ul>

Теперь подробнее о каждом из них.

<h1>Сага о пустоте</h1>

Про <b>nil</b> мы уже говорили раньше. Единственной контантой типа <b>nil</b> является... <b>nil</b>. Единственный смысл существования этого типа — быть непохожим на все другие. Все переменные, которые не были созданы через присваивание, при обращении на чтение считаются равными <b>nil</b>, поэтому не пугайтесь, если при попытке сложить переменную <i>n</i> с числом, скажем, <i>10</i>, вы получите сообщение об ошибке вроде такого:

<code lang='lua'>$ lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
> print(n+10)
stdin:1: attempt to perform arithmetic on global 'n' (a nil value)
stack traceback:
        stdin:1: in main chunk
                [C]: ?</code>

Это означает всего навсего, что вы забыли эту переменную объявить, а для типа <b>nil</b> не определены никакие операции. Значение <b>nil</b> в булевом контексте означает ложь, как я уже говорил раньше, но это не все его свойства. <b>nil</b> равен только <b>nil</b> и больше ничему:

<code lang='lua'>> print(n, m)
nil	nil
> print(n==m)
true
> print(n==0)
false
> print(n==nil)
true</code>

Можете думать о нём, как о нирване: <b>nil</b> — это состояние полного спокойствия и пустоты.

<h1>Наполняем соcуд данными</h1>

Пустота — это хорошо, но не всегда только ей можно обойтись =) 

Числа и строки представлены типами <b>number</b> и <b>string</b>.

Да, в Lua нет целого зоопарка числовых типов, вся эта сложность сокрыта от глаз простых смертных. Внутреннее машинное представление числа меняется в зависимости от контекста, динамически превращаясь то в благой integer, то в лицемерный float, но мы всего этого не увидим. Арифметически операции с числами стандартны: умножение (*), деление (/), сложение (+), вычитание (-) и возведение в степень (^). Кроме того челочисленные литералы могут записываться в шестнадцетиричном виде с префиксом <i>0x</i> (например 0x10 == 16), а числа с плавающей точкой в научной нотации с мантиссой и экспоненой (10e5 == 100000, 5e-2 == 0.05) прямо как в C.

Строки текста записываются либо в одинарных, либо в двойных кавычках, либо через специальные литеральные скобки <b>[[</b> и <b>]]</b>, которые питонщики могут сравнить с синтаксисом «длинных строк» с тройными кавычками <b>"""</b>, а перловики — с HEREDOC. Так что можно писать такие строковые литералы:

<code lang='lua'>
very_long_string_1 = [[
Эта строка содержит несколько переводов строки,
но не может содержать двух квадрадных скобок подряд.
]]
very_long_string_2 = [=[
Зато это строка может содержать символы ]] совершенно свободно.
Вот!
]=]
</code>

То есть между двумя открывающими и закрывающими литерал квадратными скобками может быть любое число знаков равно, от нуля до бесконечности, лишь бы это число совпадало у закрывающей и открывающей пары скобок, так что можно один Lua код класть в литерал другого Lua кода совершенно безопасно (если придерживаться некого соглашения о числе знаков равно в этой конструкции =).

Кроме того строки в Lua совершенно Unicode-безопасны, так что пусть у вас об этом голова не болит.

Приведение типов между <b>number</b> и <b>string</b> происходит совершенно неявно и полностью зависит от контекста, что сразу должны понять и оценить перловики:

<code lang='lua'>
> print("5" + "6")
11
> print("5" + 6, 5 + "6")
11	11
> print(5 .. 6)
56
</code>

Такая вот своеобразная магия Lua.

<h1>Условности этого мира</h1>

Булев тип в Lua называется (вы таки не поверите) <b>boolean</b>. В языке есть две встроенных константы этого типа: <b>true</b> и <b>false</b>, и, соответственно, это единственные значения, которые может принимать переменная типа <b>boolean</b>. Казалось бы тут и закончить мой рассказ, но это ещё не всё. Здесь я хочу рассказать про булевы выражения в Lua.

С арифметическим сравнением всё просто: «==» — равно, «~=» — не равно, «&lt;» и «&gt;» — меньше и больше, «&lt;=» и «&gt;=» — меньше либо равно и больше либо равно. Однако эти операции, при кажущейся простоте, не всегда кристально прозачны.

Для чисел они очевидны, для строк они проводят лексическое сравнение (то есть, например, "A" &lt; "a", a "b" &lt; "bb"), но если сравнить две переменных (или литерала) разных типов, то мы получим нечто не совсем ожиданное, а именно "10" == 10 совсем не истинно, а даже очень и очень ложно.

Почему так? Потому что операции сравнения не приводят типы неявно, как арифметические оперторы и оператор конкатенации, они сперва сравнивают типы двух сравниваемых величин, и если эти типы различны, то результат будет <b>false</b>, и плевать на содержимое. Для более сложных типов (всех, кроме <b>nil</b>, <b>number</b>, <b>string</b> и <b>boolean</b>) операции сравнения сравнивают типы и <i>ссылки</i> на объекты (а точнее <i>адреса</i>, по которым эти объекты размещены в памяти), поэтому если сравнить две переменные с типом <b>table</b>, то они окажутся равными только если ссылаются на одну и ту же таблицу.

Весь предыдущий абзац истинен только для оперций равенства и неравенства (== и ~=), все остальные операции сравнения имеют смысл только для типов <b>string</b> и <b>number</b>, при этом типы <s>операндов</s> сравниваемых значений должны быть идентичны, иначе опять будет ошибко.

Покажем на примере:

<code lang='lua'>> print("a"=="a")
true
> print(10=="10")
false
> function a() end function b() end
print(a==b) -- это два разных объекта типа «функция» с разными адресами
false
> a=b -- присвоим по ссылку на функцию b переменной a
> print(a==b) -- теперь они равны, т.к. указывают на одну и ту же функцию по одному и тому же адресу
true
> print(10>nil)
stdin:1: attempt to compare nil with number
stack traceback:
        stdin:1: in main chunk
        [C]: ?
> print(a>b)
stdin:1: attempt to compare two function values
stack traceback:
        stdin:1: in main chunk
        [C]: ?
> print("10"<5)
stdin:1: attempt to compare string with number
stack traceback:
        stdin:1: in main chunk
        [C]: ?</code>

Так что же делать, если нам надо таки сравнить число со строкой? Тут нам и понадобиться явное приведение типов, и для этого в Lua есть целых две встроенных функции! Встречайте: <b>tonumber()</b> и <b>tostring()</b>. Первая пытается из некого объекта выжать число, а если не получится, то возвращает <b>nil</b>, вторая же возвращает строку, при этом если это некий сложный тип данных, вроде функции, то вернётся символьное представление этого значения. Теперь мы можем делать так:

<code lang='lua'>> print(tonumber("10")<5)
false
> print("10"<tostring(5))
true
> function a() end function b() end
> print(tostring(a)>tostring(b))
false</code>

<s>И нас никто не остановит. Муа-ха-ха!</s>

В последнем выражении я не знаю, что у вас получится, потому что символьное представление функций a и b у вас может быть совершенно произвольное, ведь это по сути адрес в памяти в шестнадцетиричном виде:

<code lang='lua'>> print(tostring(a))
function: 0x9b11850
> print(tostring(b))
function: 0x9b118f0</code>

Ну и напоследок о булевых операциях: логические и, или и не записываются как <b>and</b>, <b>or</b> и <b>not</b>. Исключающего или нет, как его сделать представляю в качестве упражения читателям (там достаточно универского курса мат. логики... ну или почитать книжку).

Все бинарные логические опреации в Lua являются «короткими», то есть в выражении <i>A and B</i> B будет вычислено только если истинно A, а в выражении <i>A or B</i> B будет вычислено только если A ложно. Более того, эти операции возвращают не строго значения <b>true</b> или <b>false</b>, а последнее вычисленное. То есть комбинацией <b>and</b> и <b>or</b> можно до некоторой степени сэмулирвать тернарный оператор, отсутствующий в Lua:

<code lang='lua'>a = 10
b = 20
--[=[
Аналог "c? a: b" в C/Perl или "a if c else b" в Python 
]=]
print(a == b and a .. b or a + b)</code>

Обращаю внимание, также, что приоритет логических операций ниже, чем арифметических, поэтому здесь скобки не нужны. А ещё внимательный читатель должен обратить внимание на мою ремарку «сэмурировать до некоторой степени», а вот до какой степени... Считайте это ещё одним заданием на дом =)

<h1>На закуску...</h1>

я оставлю рассмотрение типов <b>table</b>, <b>thread</b>, <b>function</b> и <b>userdata</b>. Точнее перенесу их рассмотрение в следующую статью. Я честно хотел рассказать обо всех типах данных в одной статье, но вижу, что уже выложил очень много материала, и нужно дать время на его усвоение, поэтому на этом месте я прервусь.

<b>Итог:</b>

Мы рассмотрели простые типы данных <b>nil</b>, <b>number</b>, <b>string</b> и <b>boolean</b>, их запись (включая числа в шестнадцетиричном и научном видах, а строки в двойных квадратных скобках), основные операции с ними, познакомились с явным и неявным приведением типов и особенностями сравнения значений в Lua. А ещё те, кто умеет читать внимательно, научился писать однострочные и многострочные комментарии =)

В следующей статье я расскажу про остальные более сложные типы данных и основных операциях с ними.
