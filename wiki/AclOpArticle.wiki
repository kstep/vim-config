h1. Новая система описания прав

h2. Постановка задачи

h3. Проблема

В реальности права ограничивают друг от друга и задают друг другу значения по умолчанию, тем самым образуя граф зависимостей.
Эти зависимости работают на уровне конкретных прав, а не объектов, к которым они относятся, соответственно один объект может обладать целым набором прав, каждое из которых может зависеть как от прав других объектов (родительских по отношению к данному), так и от других прав этого же самого объекта. Например право на редактирование фотографии зависит от право на просмотр этой фотографии, которое, в свою очередь, зависит от права на просмотр альбома, в котором эта фотография находится. Но в то же время право на редактирование фотографии зависит и от права на редактирование альбома.
Кроме того есть ограничения на группы, которым может быть выдано каждое данное право.

К сожалению до настоящего момента не было механизма, позволяющего корректно описать все эти зависимости, т.к. все права представлялись исключительно в качестве числовых констант (битовых масок) у классов, к которым эти права привязаны. Из-за этого в шаблонах (на уровне интерфейса) функции для рисования градусников (каждый из которых по сути визуализирует одно конкретное право на один конкретный объект) передавался длинный список параметров, описывающий все сложные взаимоотношения между правами. При этом эти взаимосвязи влияли только на отображение градусников, но никак не позволяли определить права всех зависимых объектов.

В итоге:

* шаблоны непомерно раздуты лишим кодом в вызове функции для отображения градусников...
* ...и содержат код, который по сути описывает бизнес-логику взаимосвязи прав друг с другом,
* валидация прав на стороне контроллера практически невозможна без дублирования кода (а потому просто отсустствует, в лучшем случае id выбранной группы приводится к числу),
* права зависят друг от друга чисто визуально, но изменение прав одного объекта реально не влияет на права объектов, зависимых от него,
* очень трудно найти и понять, как все права зависят друг от друга, т.к. описания этих зависимостей раскиданы по шаблонам в разных местах, а не сконцентрированы рядом с моделями, к которым эти права принадлежат.

h3. Решение

Для решения вышеуказанных проблем я создал класс AclOp, который является абстракцией конкретного права. По сути этот объект инкапсулирует в себе следующие знания:

* числовую битовую маску права,
* список разрешённых для данного права типов групп,
* список других прав (объектов типа AclOp), которые ограничивают данное право,
* список других прав и типов групп, которые задают значение по умолчанию для данного права,
* всю дополнительную информацию по поведению данного права (на данный момент это флаг extendable, определяющий, есть ли у соответствующего градусника правая плашка с выбором дополнительных групп и профилей).

Кроме того этот класс инкапсулирует в себе логику зависимостей между правами, динамически подстраивая зависимые права при изменении данного права.

Дополнительно этот класс обеспечивает простой программный интерфейс для управления заданным правом, получением информации по данному праву и фильтрации свзязанных объектов с наложением данного права как фильтра.

h2. Использование AclOp в моделях

h3. Подготовка класса

Весь (не побоюсь этого слова) фреймворк Unite уже настроен на использование AclOp. Если ваш класс-модель уже наследует от PermittedModel (что скорее всего так, если вы пользуетесь системой прав Unite-а), то никаких дополнительных телодвижений делать не надо:

<pre>
<code class="python">
from unite.model.meta.permitted_model import PermittedModel

class MyModel(PermittedModel):
    __tablename__ = 'models'
</code>
</pre>

Если же нет, то перед использованием AclOp надо зарегистрировать ваш класс в классах AclOp и Acl:

<pre>
<code class="python">
from unite.model.meta.base import ActiveModel
from unite.lib.acl.acl import Acl
from unite.lib.acl.aclop import AclOp

class MyModel(ActiveModel):
    __tablename__ = 'models'
    __registered_in__ = [Acl, AclOp]
</code>
</pre>

Либо возможно использование AclOp вообще вне фреймворка Unite, тогда регистрацию необходимо совершать вручную:

<pre>
<code class="python">
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()

class MyModel(Base):
    __tablename__ = 'models'

from unite.lib.acl.acl import Acl
from unite.lib.acl.aclop import AclOp
Acl.register(MyModel)
AclOp.register(MyModel)
</code>
</pre>

Дальше я буду предполагать, что используется фреймворк Unite и ваш класс наследует от PermittedModel. Чтобы не засорять код примеров я буду опускать очевидные импорты.

h3. Описание прав

В простейшем случае описание права выглядит следующим образом:

<pre>
<code class="python">
from unite.lib.acl.aclop import AclOp

class MyModel(PermittedModel):
    __tablename__ = 'models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW)
</code>
</pre>

Здесь интерфейсом к праву просмотра MyModel будет являться поле MyModel.op_view, а битовая маска права будет равна 1.

В этом случае в левой части градусника будут отображены все группы владельца объекта класса MyModel (профиля или сообщества). Если необходимо задать подмножество групп владельца, которое допустипо отображать в левой части градусника, то можно указать параметр group_types:

<pre>
<code class="python">
class MyModel(PermittedModel):
    __tablename__ = 'models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW,
        group_types=[
            OwnerModel.GTYPE_ALL,         # Все
            OwnerModel.GTYPE_REGISTERED,  # Все зарегистрированные
            Community.GTYPE_CMEMBERS,     # Члены сообщества
            Community.GTYPE_CMODERATORS,  # Модераторы
            Community.GTYPE_CADMINS,      # Администраторы
            OwnerModel.GTYPE_SELECT,      # Выбрать
            OwnerModel.GTYPE_AUTHOR       # Только мне/автору
        ])
</code>
</pre>

Параметр group_types задаёт список типов групп, по которым будут фильтроваться группы владельца данного объекта, отображаемые в левой части градусника.

Здесь левый градусник будет содержать пункты «Все», «Все зарегистрированные», «Выбрать», «Только мне/автору», а также группы типа «Члены сообщества», «Модераторы» и «Администраторы», если владельцем объекта будет сообщество. (Обращаю внимание, что группы типов, описанных константами из OwnerModel, отображаются независимо от класса владельца.) 

Связи между правами возможны двух типов: ограничение (limit) и умолчание (default). В первой случае одно право ограничивает значение другого права тем множеством групп, для которых первое (ограничивающее право) выставлено. Иначе говоря родительское право задаёт подмножество групп и профилей, которым может быть выдано подчинённое право. Во втором случае (умолчание) родительское право задаёт значение по-умолчанию для зависящего от него право, но не ограничивает можетво возможных групп для него.

h4. Ограничивающие зависимости между правами

Ограничение задаётся параметром limit:

<pre>
<code class="python">
class MyModel(PermittedModel):
    __tablename__ = 'models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW,
        limit=[
            # op_view зависит от Community.op_view,
            # конкретное сообщество получать из поля MyModel.owner
            Community.op_view('owner')
        ])

    OP_EDIT = 2
    op_edit = AclOp(OP_EDIT,
        limit=[
            # op_edit зависит от op_view
            op_view
        ])
</code>
</pre>

Параметр limit содержит список прав, от которых зависит заданное право. В данном случае право @MyModel.op_view@ (право видеть объект MyModel) ограничено правом видеть сообщество (@Community.op_view('owner')@), а право @MyModel.op_edit@ (право редактировать объект MyModel) ограничено правом этот же объект видеть. Таким образом права могут ограничивать друг друга как на одном уровне (на уровне одного и того же объекта), так и на разных (права другого объекта (родителя, контейнера), ограничивающие права данного).

Обращаю внимание на особый синтаксис: @Community.op_view('owner')@. Дело в том, что в данном случае объекту @MyModel.op_view@ надо знать конкретного владельца (в данном случае конкретное сообщество), которое будет ограничивать права конкретного экземпляра класса MyModel. Данный синтаксис обозначает, что при необходимости конкретное сообщество можно получить из поля @MyModel.owner@ конкретного объекта класса MyModel. Также обращаю внимание, что если владельцем MyModel окажется не сообщество (объект класса Community), а, например, профиль (объект класса Profile), то данное ограничение не сработает.

Кроме того одно право может ограничиваться несколькими правами (хотя благодаря наследованию зависимостей это нужно не так уж часто):

<pre>
<code class="python">
class MyContainerModel(PermittedModel):
    __tablename__ = 'container_models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW)

class MyModel(PermittedModel):
    __tablename__ = 'models'

    container_id = Column(Integer, ForeignKey(MyContainerModel.id))
    container = relation(MyContainerModel.id)
    
    op_view = AclOp(MyContainerModel.OP_VIEW,
        limit=[
            Community.op_view('owner'),
            MyContainerModel.op_view('container')
        ])
</code>
</pre>

Здесь право @MyModel.op_view@ ограничено одновременно правом видеть соответствующее сообщество-владелец (@Community.op_view('owner')@) и правом видеть контейнер этого класса @MyContainerModel.op_view@. Хотя в большинстве случаев корректнее писать так:

<pre>
<code class="python">
class MyContainerModel(PermittedModel):
    __tablename__ = 'container_models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW,
        limit=[
            Community.op_view('owner')
        ])

class MyModel(PermittedModel):
    __tablename__ = 'models'

    container_id = Column(Integer, ForeignKey(MyContainerModel.id))
    container = relation(MyContainerModel.id)
    
    op_view = AclOp(MyContainerModel.OP_VIEW,
        limit=[
            MyContainerModel.op_view('container')
        ])
</code>
</pre>

Эффект почти такой же, т.к. право @MyModel.op_view@ по прежнему ограничено двумя правами @MyContainerModel.op_view@ и @Community.op_view@, но правом сообщества оно ограничено опосредованно через право @MyContainerModel.op_view@, плюс к тому же в этом примере право @MyContainerModel.op_view@ так же ограничено правом @Community.op_view@, чего нет в первом примере.

Возможны рекурсивные зависимости прав:

<pre>
<code class="python">
class MyTreeModel(PermittedModel):
    __tablename__ = 'tree_models'

    parent_id = Column(Integer, ForeignKey('tree_models.id'))
    parent = relation('MyTreeModel')

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW)
    op_view.limit = [op_view('parent')]
</code>
</pre>

Обращаю внимание, что зависимости прав можно указывать после того, как объект AclOp создан, присванивая значения соответствующим свойствам объекта AclOp напрямую, а не в вызове конструктора объекта.

Здесь такой подход нужен потому, что право ограничивает рекурсивно само себя, поэтому оно должно ссылаться само на себя, что до создвания объекта AclOp невозможно.

Если зависимость не может быть установлена по какой-либо причине (не найден конкретный объект, который устанавливает ограничение данному праву через своё право), то эта зависимость молча игнорируется. Это позволяет определять fallback'и в списках зависимостей. Например в таком случае:

<pre>
<code class="python">
class MyTreeModel(PermittedModel):
    __tablename__ = 'tree_models'

    parent_id = Column(Integer, ForeignKey('tree_models.id'))
    parent = relation('MyTreeModel')

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW)
    op_view.limit = [op_view('parent'), Community.op_view('owner')]
</code>
</pre>

Здесь в первую очередь будет попытка ограничить право на объект MyTreeModel через право @op_view@ его родителя (связь по полю parent, что задано вызовом @op_view('parent')@), и если объект корневой (его @parent_id@ равен @NULL@, а @parent@, соответственно, @None@), то право объекта будет ограничиено правом видеть сообщество, в которое этот объект входит (@Community.op_view('owner')@).

h4. Зависимости-умолчания

Зависимости умолчания работают аналогично ограничивающим зависимостям, но не задают жёстких ограничений, а лишь устанавливают значения по-умолчанию для новых объектов. Это зависимости устанавливаются через параметр default:

<pre>
<code class="python">
class MyContainerModel(PermittedModel):
    __tablename__ = 'container_models'

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW,
        default=[
            Community.op_view('owner')
        ])

class MyModel(PermittedModel):
    __tablename__ = 'models'

    container_id = Column(Integer, ForeignKey(MyContainerModel.id))
    container = relation(MyContainerModel.id)
    
    op_view = AclOp(MyContainerModel.OP_VIEW,
        default=[
            MyContainerModel.op_view('container')
        ])
</code>
</pre>

Этот пример совершенно аналогичен соответствующему примеру для limit, только права не ограничивают друг друга, а только выставляют значения по-умолчанию для новых объектов.Рекурсия и пропуск неопределённых прав работает точно так же, как и для ограничивающих значений, только вместо limit надо везде писать default.

Возможно использовать оба вида ограничений одновременно, вполть до таких выкрутасов:

<pre>
<code class="python">
class MyTreeModel(PermittedModel):
    __tablename__ = 'tree_models'

    parent_id = Column(Integer, ForeignKey('tree_models.id'))
    parent = relation('MyTreeModel')

    OP_VIEW = 1
    op_view = AclOp(OP_VIEW)
    op_view.limit = op_view.default = [op_view('parent'), Community.op_view('owner')]
</code>
</pre>

h4. Лже-объекты

Чтобы зависимости между правами работали корректно для новых объектов, необходимо, чтобы в соответствующих полях нового объекта (упомянутых в описании ограничений) уже были указаны родительские для него объекты. К сожалению при присвоении полям типа relation с backref-ами «живых» объектов SQLAlchemy сохраняет новый объект в базе, чтобы присвоить ему id и корректно увязать с другими объектами, что ломает всю систему =( Чтобы этого не произошло, я придумал систему фейковых объектов (или лже-объектов). Соответственно для определения градусника на странице с формой создания нового объекта надо создать соответствующий лже-объект:

<pre>
<code class="python">
class Controller(BaseController):

    def create(self, c_id):
        container = MyContainerModel.get(c_id)
        owner = container.owner
 
        # создаём лже-объект и заполняем его
        model = MyModel.fake()
        model.container = container
        model.owner = owner

        view = ControllerView(template='create_model_form.mako')
        view.add('model', model)
        return view.render()
</code>
</pre>

Отличие лже-объектов от настоящих состоит в том, что они не связаны ни с какой сессией алхимика, равно как и ни с какой таблицей в БД, все их поля по-умолчанию равны None, и они, соответственно, никогда не окажутся в БД. В остальном они ведут себя как обычные объекты, от которых они произведены, что может быть очень удобно. Например можно использовать один и тот же шаблон как для создания объекта, так и для его правки, просто передавая лже-объект в первом случае и обычный загруженный объект во втором.

h4. Дополнительные параметры

Кроме параметров @default@, @limit@, @group_types@ и битовой маски конструктор AclOp может принимать ещё один дополнительный булевый параметр @not_extended@, по-умолчанию равный @False@. Если его установить в @True@, то в градуснике, соответствующем данному право, правая плашка для выбора дополнительных групп и профилей будет скрыта. Этот параметр дополняется полем @extendable@, их соответствие описывается выражением @extendable = not not_extended@.

h2. Использование в шаблонах

Все шаблоны, описывающие градусники в интерфейсе, лежат в @templates/acl_selector.mako@. Использование шаблонов состоит из двух частей: подключения JS-библиотек и HTML-шаблонов и собственно вставки кода градусника по месту требования.

Библиотеки для использования градусников подключаются так:

<pre>
<code class="mako">
<%def name="additional_jscss()">
    <%namespace file="/acl_selector.mako" import="acl_templates" />
    ${acl_templates()}
</%def>
</code>
</pre>

Это необходимо сделать один раз на весь шаблон. После этого в нужных местах шаблона надо расставить сами градусники:

<pre>
<code class="mako">
<%namespace file="/acl_selector.mako" import="acl_js" />

<%def name="content()">
<form method="POST">
    Право видеть: ${acl_js(model.op_view)}
    Право править: ${acl_js(model.op_edit)}
    <input type="submit" />
</form>
</%def>
</code>
</pre>

По-умолчанию input-ы (и передаваемые в POST-е поля) будут называться так же, как и сами градусники, то есть в данном случае в запросе будут переданы параметры с именами @op_view@ и @op_edit@. Это рекомендуемое поведение. Если необходимо задать другое имя для input-а, его можно передать вторым параметром в вызове @acl_js()@:

<pre>
<code class="mako">
    Право видеть: ${acl_js(model.op_view, 'perm_view')}
    Право править: ${acl_js(model.op_edit, 'perm_edit')}
</code>
</pre>

Теперь input-ы будут называться @perm_view@ и @perm_edit@. В дальнейшем я буду рассматривать только простейший вариант, без кастомных имён полей.

h2. Использование в валидаторах

Для валидации прав создан специальный валидатор @AclOpValidator@. Его использование очень простое:

<pre>
<code class="python">
from formencode import Schema
from unite.lib.validators.acl import AclOpValidator
from unite.model.mymodel import MyModel

class MySchema(Schema):
    op_view = AclOpValidator(MyModel.op_view)
    op_edit = AclOpValidator(MyModel.op_edit)
</code>
</pre>

Это всё, после валидации в данных полях будут значения, полностью готовые для присвоения соответствующим полям модели MyModel.

h2. Использование в контроллерах

h3. Установка прав

Единственное требование к объекту, перед тем как ему будут заданы права: он должен уже существовать в БД, иначе будет поднято исключение @AclOpError@. Поэтому для новых объектов надо делать @Model.save()@ и @Session.flush()@ перед назначением прав. Общая канва такая:

<pre>
<code class="python">
class Controller(BaseController):

    @validate(MySchema, form='create')
    def create_submit(self):

        # создадим реальную модель в БД
        model = MyModel()
        model.save()
        Session.flush()
        
        # назначим ей права
        model.op_view = self.form_result.get('op_view', None)
        model.op_edit = self.form_result.get('op_edit', None)

        # коммит
        Session.commit()
</code>
</pre>

В простейшем случае это всё. Здесь предполагается, что данные для сохранения прав были подготовлены валидатором @AclOpValidator@ как описано в предыдущем пункте.

TODO: описать методы @AclOpProxy.append(subject)@ и @AclOpProxy.remove(subject)@, перегруженные операции сложения и вычитания.

h3. Проверка прав на объект

TODO: описать методы @AclOpProxy.can(actor)@ и @AclOpProxy.tried_by(actor)@.

h3. Фильтрация по правам

TODO: описать методы @AclOp.filter(actor)@ и @AclOp.merged(actor, filter)@.

h3. Получение данных о праве

TODO: описать свойства @AclOpProxy.groups@, @AclOpProxy.actors@, @AclOpProxy.egroups@, @AclOpProxy.eactors@, @AclOpProxy.possible_groups@, @AclOpProxy.default_groups@.

h2. Сложные проверки, использование комбинаций прав

TODO: описать использование перегруженных побитовых операций и/или/не, функции @AclOpMulti(*aclops)@.

h2. Подводные камни

TODO: описать сложности и предосторожности при работе со сложнозависимыми правами.

h2. Детали реализации

TODO: рассказать про вспомогательные классы, скрытые под верхушкой айсберга @AclOp@ (классы @AclOpProxy@ и @AclOpAlias@, создание обратных связей между @AclOp@-ами, система подписки на изменения прав через @AclOp.subscribe(other)@/@AclOp.unsubscribe(other)@ и её работа, как @AclOp@ и сотоварищи привязываются к конкретным классам/объектам полям и т.п.).

