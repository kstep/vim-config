Введение в Lua для начинающих программистов — часть 2.1

В <a href="http://welinux.ru/post/5178/">предыдущей части</a> я рассказал о самых простых типах данных в Lua, а здесь я хочу закончить разговор и типах, описав более сложные структуры данных.

[cut]

<h1>Массивы+хеши=...</h1>

В Lua нет списков. Нет в нём и массивов, равно как и словарей/хеш-таблиц, структур, перечислений (enum-ов), множеств, кортежей и объектов. Да всё это и не нужно, потому что в нём есть таблицы, в точнее тип данных <b>table</b>. Что это такое? Пхпшникам это наверное понять будет проще всего, потому что таблицы в Lua очень похожи на массивы в PHP. Таблица объединяет в себе свойста массива и словаря. (Говоря по секрету, при создании таблицы как раз резервируется две отдельные структуры: массив для данных, индексируемых по индексу, и хеш-таблица, индексируемая по произвольному текстовому ключу.) Соответственно пока возможно Lua хранит данные в таблице как в массиве (т.к. доступ к данным в массиве очень быстр, порядка O(1)), и только по необходимости переключается на хранение в хеш-таблице (то есть при использовании нечисловых ключей, или числовых ключей, идущих не подряд один за другим, так что в массиве может получиться «дырка»).

Индексация данных в таблице, используемой как массив, начинается (сюрприз-сюрприз!) с единицы, той самой, которая 1.

Теперь определимся с синтаксисом:

<code lang='lua'>
my_first_table = {}
my_first_table.field = "value"
print(my_first_table['field']) -- распечатает "value"

my_other_table = {"one", "two", "three"}
print(my_other_table[1]) -- распечатает "one"

my_hash_table = {key1 = "value1", key2 = "value2", ["key three"] = "value3"}
print(my_hash_table["key three"]) -- распечатает "value3"
my_hash_table["key three"] = "value5"
print(my_hash_table["key three"], my_hash_table.key2) -- распечатает "value5" и "value2"

my_mixed_table = {key1 = "value1", "value2", ["other key"] = "value3", key2 = "value4", [5] = "value5", "value6"}
-- таблица состоит из пар: "key1"=>"value1", 1=>"value2", "other key"=>"value3", "key2"=>"value4", 5=>"value5", 2=>"value6"
</code>

Итак конструктор таблиц — фигурные скобки <b>{</b> и <b>}</b>. Обращаться к элементам массива можно либо через квадратные скобки (my_other_table[2], my_mixed_table["other key"]), или через точку (my_hash_table.key2). Обратите внимание, что через точку можно обращаться только к элементам таблицы, ключи для которых являются корректными идентификаторами, то есть не начинаются на число и состоят только из латинских букв, цифр и знака подчёркивания, во всех остальных случаях надо использовать квадратные скобки (включая индексацию по числам в стиле массива).

Инициировать таблицу можно прямо в конструкторе, при этом через запятую передаются либо пары ключ=значение, либо просто значения. Обратите внимание на единство синтаксиса: здесь точно так же можно задавать ключи без кавычек только если они являются корректными идентификаторами, иначе их надо писать как нормальные литералы и заключать в квадратные скобки.

Ещё надо заметить то, как Lua выдаёт последовательные индексы элементам таблицы, для которых не задан ключ. Нумерация начинаются с единицы (нулевой элемент можно задать явно через [0]="value") и увеличивается с каждым новым значением <i>без ключа</i> (см. таблицу my_mixed_table в примере). Тут явно видна двойственность таблиц в Lua: объявление элементов таблицы в конструкторе без ключа добавляет их в «массивную» часть внутренней структуры <b>table</b>, а если задан ключ, то значение с этим ключём кладётся в хеш-часть таблицы. При этом счётчик элементов в массиве действует независимо от явно заданных ключей и имеет над ними приоритет. Например вот такая запись может сбить с толку:

<code lang='lua'>
-- Обе эти таблицы будут содержать массив
-- {10, 20, 30, 40}
table1 = {10, 20, 30, [4]=41, 40}
table2 = {10, 20, 30, 40, [4]=41}
</code>

<s>Проитерировть</s> перебрать все элементы массива можно с помощью специальной разновидности цикла <b>for</b>, который мы видели в прошлой статье. <s>Для этого я познакомлю вас с итераторами.</s> Подробно про итераторы я расскажу в следующей статье, здесь я только покажу их использование на практике. Для итерации по элементам таблицы в Lua есть две функции: <b>pairs()</b> и <b>ipairs()</b>. Первая итерирует по обеим частям таблицы: сначала по массиву, потом по хеш-таблице, вторая — только по «массивной» части. Поскольку лучше один раз увидеть, я сразу перейду к примеру:

<code lang='lua'>
my_mixed_table = {key1 = "value1", "value2", ["other key"] = "value3", key2 = "value4", [5] = "value5", "value6"}
for k, v in pairs(my_mixed_table) do
    print(k, v)
end
</code>

Результат:
<spoiler>
1	value2
2	value6
key1	value1
5	value5
other key	value3
key2	value4
</spoiler>

<code lang='lua'>
my_mixed_table = {key1 = "value1", "value2", ["other key"] = "value3", key2 = "value4", [5] = "value5", "value6"}
for k, v in ipairs(my_mixed_table) do
    print(k, v)
end
</code>

Результат:
<spoiler>
1	value2
2	value6
</spoiler>

Здесь мы видим, что <b>pairs()</b> и <b>ipairs()</b> выдают в цикле пары ключ-значение. (На самом деле это специальные функции-итераторы, но про них я расскажу немного позже, а тем, кому интересно, могут почитать про них дополнительно.) Здесь же мы столкнулись с новой специальной ипостасью <b>for</b> — <b>for vars in func() do ... end</b>. Сейчас можете прости принять эту форму как есть и использовать её с функциями <b>pairs()/ipairs()</b>.

Пара моментов: <b>pairs()</b> вначале выдаёт часть таблицы с массивом, а затем часть с хеш-таблицей, причём если первая часть всегда строго упорядочена, то вторая выводится в произвольном порядке.

Получить число элементов в «массивной» части таблицы можно с помощью операции "#":

<code lang='lua'>
mytable = {10, 20, 30}
print(#mytable) -- будет 3
</code>

Так что цикл <b>for k, v in ipairs(table)</b> можно заменить на такой цикл:
<code lang='lua'>
for k in 1, #mytable do
    print(k, mytable[k])
end
</code>

Ещё один немаловажный момент напоследок: хранить в таблице значения <b>nil</b> нужно с большой опаской, т.к. с точки зрения <b>pairs()</b>, <b>ipairs()</b> и <b>#</b> такие элементы не существуют и обращаться к ним получится только напрямую по ключам, если специально знать, что они по таким ключам есть. Это так потому, что значение <b>nil</b> будут иметь и те элементы таблицы, которые вы никогда не инициализировали. Например:

<code lang='lua'>
$ lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
> table1 = {10, 20, nil, 40, 50}
> print(#table1)
5
> for k, v in ipairs(table1) do print(k, v) end
1   10
2   20
> for k, v in pairs(table1) do print(k, v) end
1   10
2   20
4   40
5   50
> ------------------------------------------------------
> table2 = {10, 20, nil, 40, key1=50, key2=nil, key3=60}
> print(#table2)
4
> for k, v in ipairs(table2) do print(k, v) end
1   10
2   20
> for k, v in pairs(table2) do print(k, v) end
1   10
2   20
4   40
key1	50
key3	60
> ------------------------------------------------------
> table3 = {10, 20, nil, 40, 50, nil}
> print(#table3)
2
> for k, v in ipairs(table3) do print(k, v) end
1   10
2   20
> for k, v in pairs(table3) do print(k, v) end
1   10
2   20
4   40
5   50
</code>

Чем дальше, тем страньше... Но на самом деле всё не так страшно, как кажется: все особенности взаимоотношений таблиц и <b>nil</b> можно описать всего в паре абзацев, особенно теперь, когда мы увидели их на практике.

<b>ipairs()</b> всегда итерирует по «массивной» части таблицы до первого <b>nil</b>, <b>pairs()</b> просто пропускает все элементы, которые имеют значение <b>nil</b>. А вот оператор длинны на самом деле выдаёт такое число, что ни один следующих по порядку элементов из «массивной» части таблицы не равен <b>nil</b>. Такая вот особая лунная магия (лунная потому, что Lua по португальски означает «луна»).

Последний штрих по поводу неинициализированных элементов массива: любой элемент таблицы, который мы явно не инициализировали, равен... <b>nil</b>:

<code lang='lua'>
> table4 = {1,nil,3,key1=nil,key2=10}
> print(table4[1])
1
> print(table4[2])
nil
> print(table4[4])
nil
> print(table4[10])
nil
> print(table.key2)
10
> print(table["key1"])
nil
> print(table.key10)
nil
</code>

Теперь, надеюсь, ясно, почему такое странное поведение с элементами, равными <b>nil</b>: функции Lua не видят разницы, между неопределёнными элементами таблицы и элеметами, явно инициализированными значением <b>nil</b>. Кстати, так можно удалять любые переменные и элементы таблицы: просто присвойте им значение <b>nil</b>, и они вернуться в небытиё, из которого вышли (а за их призраками, которые остались в прошлом, прийдёт злобный <s>лангольер</s> гарбадж-коллектор).

<b>Итог:</b>

Сегодня мы познакомились с самым универсальным типом в Lua: таблицами, узнали о дуалистичной <s>корпускулярно-волновой</s> массив-словарной природе этих структур, способах их создания, обращения к их элементам, итерации по ним, узнали как определять число элементов в таблицах и о сложных взаимоотношениях таблиц с <b>nil</b>-ом.

В следующей <s>серии нашего сериала</s> статье я расскажу много интересного о тайной жизни функций в Lua.

